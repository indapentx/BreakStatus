<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bus Status</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --bg: #ffffff;
        --surface: #f4f4f4;
        --card: #ffffff;
        --text: #111111;
        --subtle: #6b6b6b;
        --border: #e3e3e3;
        --accent: #111111;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        margin: 0;
        padding: 2rem 1.5rem 3rem;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        justify-content: center;
      }

      main {
        width: min(960px, 100%);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      header {
        text-align: left;
      }

      h1 {
        margin: 0 0 0.35rem;
        font-size: clamp(2rem, 4vw, 2.5rem);
        letter-spacing: -0.02em;
      }

      header p {
        margin: 0;
        color: var(--subtle);
        max-width: 52ch;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 20px;
        padding: 1.75rem;
        box-shadow: 0 20px 40px rgba(17, 17, 17, 0.03);
      }

      .auth-card form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .auth-toggle {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.35rem;
        background: var(--surface);
        padding: 0.25rem;
        border-radius: 999px;
        border: 1px solid var(--border);
      }

      .auth-toggle button {
        border: none;
        background: transparent;
        color: var(--subtle);
        font-weight: 600;
        border-radius: 999px;
        padding: 0.65rem 0.5rem;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .auth-toggle button.active {
        background: var(--card);
        color: var(--text);
        box-shadow: 0 6px 12px rgba(17, 17, 17, 0.08);
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--subtle);
      }

      input {
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0.85rem 1.1rem;
        font-size: 1rem;
        background: var(--surface);
        color: var(--text);
      }

      input:focus-visible {
        outline: 2px solid var(--text);
        outline-offset: 2px;
      }

      .form-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 0.85rem 1.4rem;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        background: var(--accent);
        color: var(--bg);
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      button.ghost {
        background: transparent;
        color: var(--text);
        border: 1px solid var(--border);
      }

      button:disabled {
        opacity: 0.35;
        cursor: not-allowed;
      }

      button:not(:disabled):hover {
        opacity: 0.9;
      }

      .muted {
        color: var(--subtle);
        font-size: 0.9rem;
        margin-top: 0.25rem;
        min-height: 1.25rem;
      }

      .field-hint {
        font-size: 0.8rem;
        color: var(--subtle);
      }

      .full-name-field.hidden {
        display: none;
      }

      .muted.error {
        color: #b3261e;
      }

      .dashboard {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .user-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .eyebrow {
        text-transform: uppercase;
        font-size: 0.75rem;
        letter-spacing: 0.15em;
        color: var(--subtle);
        margin: 0;
      }

      .user-email {
        margin: 0.25rem 0 0;
        font-size: 1.35rem;
        font-weight: 600;
      }

      .lists {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1rem;
      }

      .list-column {
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1.2rem;
        background: var(--surface);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .list-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
      }

      h2 {
        margin: 0;
        font-size: 1.1rem;
        letter-spacing: -0.01em;
      }

      .status-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .status-list li {
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--card);
        padding: 0.9rem 1rem;
        font-weight: 500;
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        align-items: center;
      }

      .status-list .empty {
        color: var(--subtle);
        font-weight: 400;
        font-size: 0.95rem;
      }

      .person {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
      }

      .person-name {
        font-weight: 600;
      }

      .person-email {
        font-size: 0.85rem;
        color: var(--subtle);
        font-weight: 400;
      }

      .time-badge {
        font-size: 0.8rem;
        font-weight: 500;
        color: var(--subtle);
      }

      .hidden {
        display: none;
      }

      @media (max-width: 640px) {
        body {
          padding: 1.25rem;
        }

        .form-actions {
          flex-direction: column;
        }

        .user-row {
          flex-direction: column;
          align-items: flex-start;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header id="site-header" class="hidden">
        <h1>Bus Status</h1>
        <p>
          Made by Furkan Öztürk for Trend ISG.
        </p>
      </header>

      <section class="card auth-card" id="auth-card">
        <form id="auth-form" autocomplete="on">
          <div class="auth-toggle" role="tablist" aria-label="Authentication mode">
            <button type="button" data-auth-mode="signin" class="active" aria-pressed="true">
              Sign In
            </button>
            <button type="button" data-auth-mode="register" aria-pressed="false">
              Create Account
            </button>
          </div>
          <label>
            Email
            <input type="email" id="email" name="email" placeholder="you@email.com" required />
          </label>
          <div class="full-name-field hidden" id="full-name-field">
            <label>
              Full name
              <input
                type="text"
                id="full-name"
                name="fullName"
                placeholder="Jessica Lee"
                autocomplete="name"
              />
            </label>
          </div>
          <label>
            Password
            <input
              type="password"
              id="password"
              name="password"
              minlength="6"
              placeholder="Minimum 6 characters"
              required
            />
          </label>
          <div class="form-actions">
            <button type="submit" id="auth-submit">Sign In</button>
          </div>
        </form>
        <p class="muted" id="auth-message">
          Email + password auth is powered by Firebase. Add your project config before deploying.
        </p>
      </section>

      <section class="card dashboard hidden" id="dashboard">
        <div class="user-row">
          <div>
            <p class="eyebrow">Signed in as</p>
            <p class="user-email" id="user-email">—</p>
          </div>
          <button class="ghost" id="sign-out">Sign Out</button>
        </div>

        <div class="lists">
          <div class="list-column">
            <div class="list-header">
              <h2>On the bus</h2>
              <button id="leave-btn" class="ghost" type="button" disabled>Leave list</button>
            </div>
            <ul class="status-list" id="on-bus">
              <li class="empty">Sign in to see the roster.</li>
            </ul>
          </div>
          <div class="list-column">
            <div class="list-header">
              <h2>Not on the bus</h2>
              <button id="join-btn" type="button" disabled>Join bus</button>
            </div>
            <ul class="status-list" id="off-bus">
              <li class="empty">Sign in to see the roster.</li>
            </ul>
          </div>
        </div>
        <p class="muted" id="roster-message"></p>
        <p class="muted" id="group-message"></p>
      </section>
    </main>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
      import {
        getAuth,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        createUserWithEmailAndPassword,
        signOut,
      } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
      import {
        getFirestore,
        doc,
        setDoc,
        getDoc,
        collection,
        onSnapshot,
        serverTimestamp,
      } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDHZz5fVOTvnokTuTUjNSC5QSiC7mFxyZM",
        authDomain: "trend-isg.firebaseapp.com",
        projectId: "trend-isg",
        storageBucket: "trend-isg.firebasestorage.app",
        messagingSenderId: "751472868865",
        appId: "1:751472868865:web:eb6702b74236d19913ca00",
      };

      const GROUPS = Object.freeze({
        A: "Group A",
        B: "Group B",
        C: "Group C",
        D: "Group D",
      });

      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);

      const authCard = document.getElementById("auth-card");
      const siteHeader = document.getElementById("site-header");
      const dashboard = document.getElementById("dashboard");
      const authForm = document.getElementById("auth-form");
      const emailInput = document.getElementById("email");
      const fullNameInput = document.getElementById("full-name");
      const passwordInput = document.getElementById("password");
      const modeButtons = document.querySelectorAll("[data-auth-mode]");
      const fullNameField = document.getElementById("full-name-field");
      const authSubmitButton = document.getElementById("auth-submit");
      const authMessage = document.getElementById("auth-message");
      const rosterMessage = document.getElementById("roster-message");
      const groupMessage = document.getElementById("group-message");
      const joinButton = document.getElementById("join-btn");
      const leaveButton = document.getElementById("leave-btn");
      const onBusList = document.getElementById("on-bus");
      const offBusList = document.getElementById("off-bus");
      const userEmailEl = document.getElementById("user-email");
      const signOutButton = document.getElementById("sign-out");

      let authMode = "signin";
      let currentUser = null;
      let currentGroupId = null;
      let currentProfile = { fullName: "" };
      let pendingIdentity = null;
      let rosterEntries = [];
      let rosterUnsubscribe = null;
      let groupUnsubscribe = null;
      let selfEntry = null;
      let isRosterMutating = false;

      function toggleViews(isSignedIn) {
        if (isSignedIn) {
          authCard.classList.add("hidden");
          dashboard.classList.remove("hidden");
          siteHeader?.classList.remove("hidden");
        } else {
          authCard.classList.remove("hidden");
          dashboard.classList.add("hidden");
          siteHeader?.classList.add("hidden");
        }
      }

      function setAuthMessage(message, isError = false) {
        authMessage.textContent = message;
        authMessage.classList.toggle("error", isError);
      }

      function setRosterMessage(message = "", isError = false) {
        if (!rosterMessage) return;
        rosterMessage.textContent = message;
        rosterMessage.classList.toggle("error", isError);
      }

      function setGroupMessage(message = "", isError = false) {
        if (!groupMessage) return;
        groupMessage.textContent = message;
        groupMessage.classList.toggle("error", isError);
      }

      function setAuthMode(mode) {
        authMode = mode === "register" ? "register" : "signin";
        const needsFullName = authMode === "register";
        modeButtons.forEach((button) => {
          const isActive = button.dataset.authMode === authMode;
          button.classList.toggle("active", isActive);
          button.setAttribute("aria-pressed", String(isActive));
        });
        fullNameField.classList.toggle("hidden", !needsFullName);
        fullNameInput.required = needsFullName;
        authSubmitButton.textContent = needsFullName ? "Create Account" : "Sign In";
        if (needsFullName) {
          attemptFullNamePrefill();
        }
        setAuthMessage("");
      }

      function isValidGroupId(groupId) {
        return Boolean(groupId && GROUPS[groupId]);
      }

      function groupLabel(groupId) {
        return GROUPS[groupId] ?? groupId ?? "Unknown";
      }

      function sanitizeFullName(value) {
        return value ? value.replace(/\s+/g, " ").trim() : "";
      }

      function rememberFullName(email, fullName) {
        if (!email || !fullName) return;
        try {
          localStorage.setItem(`fullName:${email}`, fullName);
        } catch {
          /* ignore storage issues */
        }
      }

      function recallFullName(email) {
        if (!email) return "";
        try {
          return localStorage.getItem(`fullName:${email}`) ?? "";
        } catch {
          return "";
        }
      }

      function getCurrentFullName() {
        return (
          sanitizeFullName(currentProfile?.fullName) ||
          sanitizeFullName(pendingIdentity?.fullName) ||
          ""
        );
      }

      async function saveProfileFullName(user, fullName) {
        if (!user || !fullName) return;
        const profileRef = doc(db, "userProfiles", user.uid);
        try {
          await setDoc(
            profileRef,
            {
              fullName,
              email: user.email,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          currentProfile = { fullName };
        } catch (error) {
          console.error("Unable to save profile name", error);
          throw error;
        }
      }

      async function fetchProfile(user) {
        if (!user) return null;
        try {
          const snapshot = await getDoc(doc(db, "userProfiles", user.uid));
          if (snapshot.exists()) {
            return snapshot.data();
          }
        } catch (error) {
          console.error("Unable to load profile", error);
        }
        return null;
      }

      function toDate(value) {
        if (!value) return null;
        if (typeof value.toDate === "function") {
          try {
            return value.toDate();
          } catch {
            return null;
          }
        }
        const date = new Date(value);
        return Number.isNaN(date.getTime()) ? null : date;
      }

      function getTimestampValue(value) {
        const date = toDate(value);
        return date ? date.getTime() : Number.MAX_SAFE_INTEGER;
      }

      function formatTime(value) {
        const date = toDate(value);
        if (!date) return "--:--";
        try {
          return new Intl.DateTimeFormat([], {
            hour: "numeric",
            minute: "2-digit",
          }).format(date);
        } catch {
          return "--:--";
        }
      }

      function updateActionButtons() {
        if (!currentUser || !currentGroupId) {
          joinButton.disabled = true;
          leaveButton.disabled = true;
          return;
        }
        const entry =
          rosterEntries.find((record) => record.id === currentUser.uid) ?? selfEntry;
        const isOnBus = Boolean(entry?.isOnBus);
        joinButton.disabled = isRosterMutating || isOnBus;
        leaveButton.disabled = isRosterMutating || !isOnBus;
      }

      function createListItem(entry, { showJoinedAt = false } = {}) {
        const li = document.createElement("li");

        const person = document.createElement("span");
        person.className = "person";

        const nameSpan = document.createElement("span");
        nameSpan.className = "person-name";
        nameSpan.textContent = entry.fullName ?? entry.email ?? "Unknown rider";
        person.appendChild(nameSpan);

        if (entry.email) {
          const emailSpan = document.createElement("span");
          emailSpan.className = "person-email";
          emailSpan.textContent = entry.email;
          person.appendChild(emailSpan);
        }

        li.appendChild(person);

        if (showJoinedAt && entry.joinedAt) {
          const timeSpan = document.createElement("span");
          timeSpan.className = "time-badge";
          timeSpan.textContent = formatTime(entry.joinedAt);
          li.appendChild(timeSpan);
        }

        return li;
      }

      function populateList(target, entries, emptyText, options = {}) {
        if (!entries.length) {
          target.innerHTML = `<li class="empty">${emptyText}</li>`;
          return;
        }
        const fragment = document.createDocumentFragment();
        entries.forEach((entry) => {
          fragment.appendChild(createListItem(entry, options));
        });
        target.replaceChildren(fragment);
      }

      function renderLists() {
        if (!currentUser) {
          onBusList.innerHTML = '<li class="empty">Sign in to see the roster.</li>';
          offBusList.innerHTML = '<li class="empty">Sign in to see the roster.</li>';
          updateActionButtons();
          return;
        }

        if (!currentGroupId) {
          const awaiting = "Waiting for a group assignment.";
          onBusList.innerHTML = `<li class="empty">${awaiting}</li>`;
          offBusList.innerHTML = `<li class="empty">${awaiting}</li>`;
          updateActionButtons();
          return;
        }

        const onBusEntries = rosterEntries.filter((entry) => entry.isOnBus);
        const offBusEntries = rosterEntries.filter((entry) => !entry.isOnBus);

        const onBusSorted = [...onBusEntries].sort(
          (a, b) => getTimestampValue(a.joinedAt) - getTimestampValue(b.joinedAt)
        );
        const offBusSorted = [...offBusEntries].sort((a, b) =>
          (a.email ?? "").localeCompare(b.email ?? "", undefined, { sensitivity: "base" })
        );

        populateList(onBusList, onBusSorted, "Nobody is on the bus right now.", {
          showJoinedAt: true,
        });
        populateList(offBusList, offBusSorted, "Everyone is already on board.");
        updateActionButtons();
      }

      async function ensureRosterEntry(user, groupId) {
        if (!user || !groupId) return;
        const ref = doc(db, "groups", groupId, "busRoster", user.uid);
        const fullName = getCurrentFullName() || user.email;
        try {
          const snapshot = await getDoc(ref);
          if (!snapshot.exists()) {
            const seed = {
              email: user.email,
              fullName,
              isOnBus: false,
              joinedAt: null,
              updatedAt: serverTimestamp(),
            };
            await setDoc(ref, seed);
            selfEntry = { id: user.uid, ...seed };
          } else {
            const data = snapshot.data();
            selfEntry = { id: user.uid, ...data };
            if (fullName && data.fullName !== fullName) {
              await setDoc(
                ref,
                {
                  fullName,
                  email: user.email,
                  updatedAt: serverTimestamp(),
                },
                { merge: true }
              );
              selfEntry.fullName = fullName;
            }
          }
          updateActionButtons();
        } catch (error) {
          console.error("Unable to prepare roster entry", error);
          setRosterMessage("Unable to prepare your roster slot.", true);
        }
      }

      function startRosterSubscription(groupId) {
        if (!groupId) return;
        stopRosterSubscription();
        const rosterRef = collection(db, "groups", groupId, "busRoster");
        rosterUnsubscribe = onSnapshot(
          rosterRef,
          (snapshot) => {
            rosterEntries = snapshot.docs.map((docSnap) => ({
              id: docSnap.id,
              ...docSnap.data(),
            }));
            if (currentUser) {
              const latestSelf = rosterEntries.find((entry) => entry.id === currentUser.uid);
              if (latestSelf) {
                selfEntry = latestSelf;
              }
            }
            renderLists();
          },
          (error) => {
            console.error("Roster listener error", error);
            setRosterMessage("Live roster updates paused. Refresh the page.", true);
          }
        );
      }

      function stopRosterSubscription() {
        if (rosterUnsubscribe) {
          rosterUnsubscribe();
          rosterUnsubscribe = null;
        }
        rosterEntries = [];
        selfEntry = null;
        renderLists();
      }

      function startGroupWatcher(user) {
        stopGroupWatcher();
        if (!user) return;
        const groupRef = doc(db, "userGroups", user.uid);
        groupUnsubscribe = onSnapshot(
          groupRef,
          (snapshot) => {
            handleGroupSnapshot(snapshot).catch((error) => {
              console.error("Group handling failed", error);
              setGroupMessage("Unable to load your group.", true);
            });
          },
          (error) => {
            console.error("Group listener error", error);
            currentGroupId = null;
            setGroupMessage("Unable to load your group.", true);
            stopRosterSubscription();
            updateActionButtons();
          }
        );
      }

      function stopGroupWatcher() {
        if (groupUnsubscribe) {
          groupUnsubscribe();
          groupUnsubscribe = null;
        }
      }

      async function handleGroupSnapshot(snapshot) {
        if (!currentUser) return;
        if (!snapshot.exists()) {
          currentGroupId = null;
          setGroupMessage("No group assigned. Contact the owner.", true);
          stopRosterSubscription();
          updateActionButtons();
          return;
        }
        const data = snapshot.data();
        const groupId = data.groupId;
        if (!isValidGroupId(groupId)) {
          currentGroupId = null;
          setGroupMessage("Invalid group assignment. Contact the owner.", true);
          stopRosterSubscription();
          updateActionButtons();
          return;
        }
        if (groupId === currentGroupId) {
          setGroupMessage(`Group: ${groupLabel(groupId)}`);
          return;
        }
        currentGroupId = groupId;
        setGroupMessage(`Group: ${groupLabel(groupId)}`);
        setRosterMessage("");
        stopRosterSubscription();
        await ensureRosterEntry(currentUser, groupId);
        startRosterSubscription(groupId);
      }

      async function updateBusStatus(targetState) {
        if (!currentUser || !currentGroupId || isRosterMutating) {
          if (!currentGroupId) {
            setRosterMessage("You need a group before toggling the bus.", true);
          }
          return;
        }
        isRosterMutating = true;
        updateActionButtons();
        setRosterMessage(targetState ? "Joining the bus…" : "Leaving the bus…");

        const fullName = getCurrentFullName() || currentUser.email;
        const optimisticEntry = {
          id: currentUser.uid,
          email: currentUser.email,
          fullName,
          isOnBus: targetState,
          joinedAt: targetState ? new Date() : null,
        };
        const index = rosterEntries.findIndex((entry) => entry.id === currentUser.uid);
        if (index >= 0) {
          rosterEntries[index] = { ...rosterEntries[index], ...optimisticEntry };
        } else {
          rosterEntries = [...rosterEntries, optimisticEntry];
        }
        selfEntry = optimisticEntry;
        renderLists();

        try {
          await setDoc(
            doc(db, "groups", currentGroupId, "busRoster", currentUser.uid),
            {
              email: currentUser.email,
              fullName,
              isOnBus: targetState,
              joinedAt: targetState ? serverTimestamp() : null,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          setRosterMessage(targetState ? "You are on the bus." : "You left the bus.");
        } catch (error) {
          console.error("Roster update failed", error);
          setRosterMessage("Update failed. Please try again.", true);
        } finally {
          isRosterMutating = false;
          updateActionButtons();
        }
      }

      function attemptFullNamePrefill() {
        if (authMode !== "register") return;
        const suggestion = recallFullName(emailInput.value.trim());
        if (suggestion && !fullNameInput.value.trim()) {
          fullNameInput.value = suggestion;
        }
      }

      modeButtons.forEach((button) => {
        button.addEventListener("click", () => setAuthMode(button.dataset.authMode));
      });

      setAuthMode("signin");

      emailInput.addEventListener("blur", attemptFullNamePrefill);
      emailInput.addEventListener("change", attemptFullNamePrefill);

      authForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const email = emailInput.value.trim();
        const isRegister = authMode === "register";
        const fullName = isRegister ? sanitizeFullName(fullNameInput.value) : "";
        if (isRegister) {
          fullNameInput.value = fullName;
        }
        const password = passwordInput.value.trim();

        if (!email) {
          setAuthMessage("Enter an email address.", true);
          return;
        }

        if (!password) {
          setAuthMessage("Enter a password.", true);
          return;
        }

        if (isRegister && !fullName) {
          setAuthMessage("Enter your full name.", true);
          return;
        }

        if (isRegister) {
          pendingIdentity = { email, fullName };
          rememberFullName(email, fullName);
        } else {
          pendingIdentity = null;
        }

        try {
          if (isRegister) {
            setAuthMessage("Creating your account…");
            await createUserWithEmailAndPassword(auth, email, password);
            setAuthMessage("Account created. Signing you in…");
          } else {
            setAuthMessage("Signing you in…");
            await signInWithEmailAndPassword(auth, email, password);
            setAuthMessage("Signed in.");
          }
        } catch (error) {
          const friendly =
            typeof error?.code === "string"
              ? error.code.replace("auth/", "").replace(/-/g, " ")
              : "Something went wrong. Try again.";
          setAuthMessage(friendly, true);
          pendingIdentity = null;
        }
      });

      joinButton.addEventListener("click", () => updateBusStatus(true));
      leaveButton.addEventListener("click", () => updateBusStatus(false));

      signOutButton.addEventListener("click", async () => {
        try {
          await signOut(auth);
          setAuthMessage("Signed out.");
        } catch {
          setAuthMessage("Unable to sign out. Try again.", true);
        }
      });

      onAuthStateChanged(auth, async (user) => {
        currentUser = user;
        if (user) {
          userEmailEl.textContent = user.email;
          setRosterMessage("");
          setGroupMessage("Looking up your group…");
          try {
            if (pendingIdentity && pendingIdentity.email === user.email) {
              await saveProfileFullName(user, pendingIdentity.fullName);
              rememberFullName(user.email, pendingIdentity.fullName);
            } else {
              const profile = await fetchProfile(user);
              currentProfile = profile?.fullName
                ? { fullName: sanitizeFullName(profile.fullName) }
                : { fullName: "" };
              if (!currentProfile.fullName) {
                const suggestion = recallFullName(user.email);
                if (suggestion) {
                  currentProfile.fullName = suggestion;
                  rememberFullName(user.email, suggestion);
                } else {
                  setAuthMessage("Add your full name when signing in next time.", true);
                }
              } else {
                rememberFullName(user.email, currentProfile.fullName);
              }
            }
          } catch {
            setAuthMessage("Unable to sync your full name. Try again.", true);
          } finally {
            pendingIdentity = null;
          }
          startGroupWatcher(user);
        } else {
          userEmailEl.textContent = "—";
          setRosterMessage("");
          setGroupMessage("");
          currentGroupId = null;
          currentProfile = { fullName: "" };
          pendingIdentity = null;
          stopGroupWatcher();
          stopRosterSubscription();
        }
        toggleViews(Boolean(user));
        renderLists();
      });

      renderLists();
    </script>
  </body>
</html>
