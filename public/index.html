<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Trend ISG</title>
    <link rel="icon" type="image/png" sizes="512x512" href="indapentx.png" />
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --bg: #ffffff;
        --surface: #f4f4f4;
        --card: #ffffff;
        --text: #111111;
        --subtle: #6b6b6b;
        --border: #e3e3e3;
        --accent: #111111;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        margin: 0;
        padding: 2rem 1.5rem 3rem;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        justify-content: center;
      }

      main {
        width: min(960px, 100%);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      header {
        text-align: left;
      }

      h1 {
        margin: 0 0 0.35rem;
        font-size: clamp(2rem, 4vw, 2.5rem);
        letter-spacing: -0.02em;
      }

      header p {
        margin: 0;
        color: var(--subtle);
        max-width: 52ch;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 20px;
        padding: 1.75rem;
        box-shadow: 0 20px 40px rgba(17, 17, 17, 0.03);
      }

      .auth-card form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .auth-toggle {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.35rem;
        background: var(--surface);
        padding: 0.25rem;
        border-radius: 999px;
        border: 1px solid var(--border);
      }

      .auth-toggle button {
        border: none;
        background: transparent;
        color: var(--subtle);
        font-weight: 600;
        border-radius: 999px;
        padding: 0.65rem 0.5rem;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .auth-toggle button.active {
        background: var(--card);
        color: var(--text);
        box-shadow: 0 6px 12px rgba(17, 17, 17, 0.08);
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--subtle);
      }

      input {
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0.85rem 1.1rem;
        font-size: 1rem;
        background: var(--surface);
        color: var(--text);
      }

      input:focus-visible {
        outline: 2px solid var(--text);
        outline-offset: 2px;
      }

      .form-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 0.85rem 1.4rem;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        background: var(--accent);
        color: var(--bg);
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      button.ghost {
        background: transparent;
        color: var(--text);
        border: 1px solid var(--border);
      }

      button:disabled {
        opacity: 0.35;
        cursor: not-allowed;
      }

      button:not(:disabled):hover {
        opacity: 0.9;
      }

      .muted {
        color: var(--subtle);
        font-size: 0.9rem;
        margin: 0;
        min-height: 1.25rem;
      }

      .muted:empty {
        display: none;
      }

      .field-hint {
        font-size: 0.8rem;
        color: var(--subtle);
      }

      #auth-message {
        margin-top: 1rem;
      }

      .full-name-field.hidden {
        display: none;
      }

      .password-input {
        position: relative;
      }

      .password-input input {
        width: 100%;
        padding-right: 4.75rem;
      }

      .password-visibility {
        position: absolute;
        right: 0.35rem;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        color: var(--text);
        padding: 0.35rem 0.75rem;
        font-size: 0.85rem;
        font-weight: 600;
        border: none;
      }

      .password-visibility:hover {
        opacity: 0.7;
      }

      .password-visibility:focus-visible {
        outline: 2px solid var(--text);
        outline-offset: 3px;
      }

      .muted.error {
        color: #b3261e;
      }

      .dashboard {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .user-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .eyebrow {
        text-transform: uppercase;
        font-size: 0.75rem;
        letter-spacing: 0.15em;
        color: var(--subtle);
        margin: 0;
      }

      .user-email {
        margin: 0.25rem 0 0;
        font-size: 1.35rem;
        font-weight: 600;
      }

      .lists {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1rem;
      }

      .list-column {
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1.2rem;
        background: var(--surface);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .list-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
      }

      h2 {
        margin: 0;
        font-size: 1.1rem;
        letter-spacing: -0.01em;
      }

      .status-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .status-list li {
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--card);
        padding: 0.9rem 1rem;
        font-weight: 500;
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        align-items: center;
      }

      .status-list .empty {
        color: var(--subtle);
        font-weight: 400;
        font-size: 0.95rem;
      }

      .person {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
      }

      .person-name {
        font-weight: 600;
      }

      .person-email {
        font-size: 0.85rem;
        color: var(--subtle);
        font-weight: 400;
      }

      .duty-tag {
        display: inline-flex;
        align-items: center;
        padding: 0.1rem 0.55rem;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: var(--surface);
        font-size: 0.75rem;
        font-weight: 500;
        color: var(--subtle);
      }

      .time-badge {
        font-size: 0.8rem;
        font-weight: 500;
        color: var(--subtle);
      }

      .hidden {
        display: none;
      }

      .admin-panel {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .admin-panel.hidden {
        display: none;
      }

      .admin-groups {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1rem;
      }

      .admin-group-card {
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1rem;
        background: var(--surface);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .admin-group-card h3 {
        margin: 0;
        letter-spacing: -0.01em;
        text-transform: capitalize;
      }

      .admin-group-card .status-list {
        background: transparent;
      }

      .admin-group-divider {
        height: 1px;
        width: 100%;
        background: var(--border);
      }

      .duty-section,
      .break-section {
        margin-top: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .duty-header,
      .break-header {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        gap: 0.75rem;
      }

      .duty-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.5rem;
      }

      .duty-select-label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--subtle);
      }

      .duty-select {
        border-radius: 999px;
        border: 1px solid var(--border);
        background: var(--surface);
        padding: 0.5rem 0.9rem;
        font-size: 0.9rem;
        min-width: 200px;
      }

      .break-controls {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      body.app-loading {
        position: relative;
      }

      body.app-loading main {
        visibility: hidden;
      }

      body.app-loading::before {
        content: "Loading…";
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--bg);
        color: var(--subtle);
        font-size: 0.95rem;
      }

      @media (max-width: 640px) {
        body {
          padding: 1.25rem;
        }

        .form-actions {
          flex-direction: column;
        }

        .user-row {
          flex-direction: column;
          align-items: flex-start;
        }
      }
    </style>
  </head>
  <body class="app-loading">
    <main>
      <header id="site-header">
        <h1>Bus Status</h1>
        <p>
          Made by Furkan Öztürk for Trend ISG.
        </p>
      </header>

      <section class="card auth-card" id="auth-card">
        <form id="auth-form" autocomplete="on">
          <div class="auth-toggle" role="tablist" aria-label="Authentication mode">
            <button type="button" data-auth-mode="signin" class="active" aria-pressed="true">
              Sign In
            </button>
            <button type="button" data-auth-mode="register" aria-pressed="false">
              Create Account
            </button>
          </div>
          <label>
            Email
            <input type="email" id="email" name="email" placeholder="you@email.com" required />
          </label>
          <div class="full-name-field hidden" id="full-name-field">
            <label>
              Full name
              <input
                type="text"
                id="full-name"
                name="fullName"
                placeholder="Saul Goodman"
                autocomplete="name"
              />
            </label>
          </div>
          <label>
            Password
            <div class="password-input">
              <input
                type="password"
                id="password"
                name="password"
                minlength="6"
                placeholder="Minimum 6 characters"
                required
              />
              <button
                type="button"
                class="password-visibility"
                id="password-visibility"
                aria-pressed="false"
              >
                Show
              </button>
            </div>
          </label>
          <div class="form-actions">
            <button type="submit" id="auth-submit">Sign In</button>
          </div>
        </form>
        <p class="muted" id="auth-message">Use your credentials to access the dashboard.</p>
      </section>

      <section class="card dashboard hidden" id="dashboard">
        <div class="user-row">
          <div>
            <p class="eyebrow">Signed in as</p>
            <p class="user-email" id="user-email">—</p>
          </div>
          <button class="ghost" id="sign-out">Sign Out</button>
        </div>

        <div class="lists">
          <div class="list-column">
            <div class="list-header">
              <h2>On the bus</h2>
              <button id="leave-btn" class="ghost" type="button" disabled>Leave list</button>
            </div>
            <ul class="status-list" id="on-bus">
              <li class="empty">Sign in to see the roster.</li>
            </ul>
          </div>
          <div class="list-column">
            <div class="list-header">
              <h2>Not on the bus</h2>
              <button id="join-btn" type="button" disabled>Join bus</button>
            </div>
            <ul class="status-list" id="off-bus">
              <li class="empty">Sign in to see the roster.</li>
            </ul>
          </div>
        </div>
        <p class="muted" id="roster-message"></p>
        <p class="muted" id="group-message"></p>

        <section class="break-section" aria-label="Break status">
          <div class="break-header">
            <h2>Break status (today)</h2>
          </div>
          <div class="lists break-lists">
            <div class="list-column">
              <div class="list-header">
                <h2>On break</h2>
                <button id="break-leave-btn" class="ghost" type="button" disabled>
                  End break
                </button>
              </div>
              <ul class="status-list" id="break-on">
                <li class="empty">Sign in to see who is on break.</li>
              </ul>
            </div>
            <div class="list-column">
              <div class="list-header">
                <h2>Not on break</h2>
                <button id="break-join-btn" type="button" disabled>Start break</button>
              </div>
              <ul class="status-list" id="break-off">
                <li class="empty">Sign in to see who is not on break.</li>
              </ul>
            </div>
          </div>
          <p class="muted" id="break-message"></p>
        </section>

        <section class="duty-section" aria-label="Duty placements">
          <div class="duty-header">
            <h2>Duty placements (today)</h2>
            <div class="duty-controls">
              <label class="duty-select-label">
                Your duty
                <select id="duty-select" class="duty-select">
                  <option value="">Not assigned</option>
                  <option value="dis_hatlar">International Departures</option>
                  <option value="ic_hatlar">Domestic Departures</option>
                  <option value="e_pasaport_dis_hatlar">E-pasaport (dis hatlar)</option>
                  <option value="e_pasaport_gelen_yolcu">E-pasaport (gelen yolcu)</option>
                  <option value="uzak_ucus">Uzak ucus</option>
                  <option value="valilik">Valilik</option>
                </select>
              </label>
              <button id="duty-save" type="button" class="ghost">Update duty</button>
            </div>
          </div>
          <div class="lists duty-lists" id="duty-lists">
            <p class="muted">Sign in to see duty placements.</p>
          </div>
          <p class="muted" id="duty-message"></p>
        </section>
      </section>

      <section class="card admin-panel hidden" id="admin-panel">
	        <div class="user-row">
	          <div>
	            <p class="eyebrow">Staff view</p>
            <p class="user-email" id="admin-user-email">—</p>
          </div>
          <button class="ghost" id="admin-sign-out">Sign Out</button>
        </div>
        <div class="admin-groups" id="admin-groups">
          <p class="muted">Loading group data…</p>
        </div>
      </section>
    </main>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
      import {
        getAuth,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        createUserWithEmailAndPassword,
        signOut,
      } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
      import {
        getFirestore,
        doc,
        setDoc,
        getDoc,
        getDocs,
        collection,
        onSnapshot,
        serverTimestamp,
        writeBatch,
        runTransaction,
      } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDHZz5fVOTvnokTuTUjNSC5QSiC7mFxyZM",
        authDomain: "trend-isg.firebaseapp.com",
        projectId: "trend-isg",
        storageBucket: "trend-isg.firebasestorage.app",
        messagingSenderId: "751472868865",
        appId: "1:751472868865:web:eb6702b74236d19913ca00",
      };

      const GROUPS = Object.freeze({
        A: "A",
        B: "B",
        C: "C",
        D: "D",
      });

      const ADMIN_EMAILS = new Set([
        "furkan.ozturk@gmail.com",
      ]);

      const DUTY_PLACES = Object.freeze([
        { id: "dis_hatlar", label: "International Departures" },
        { id: "ic_hatlar", label: "Domestic Departures" },
        { id: "e_pasaport_dis_hatlar", label: "E-pasaport (dis hatlar)" },
        { id: "e_pasaport_gelen_yolcu", label: "E-pasaport (gelen yolcu)" },
        { id: "uzak_ucus", label: "Uzak ucus" },
        { id: "valilik", label: "Valilik" },
      ]);

      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);
      const RESET_TIMEZONE = "Europe/Istanbul";

      const authCard = document.getElementById("auth-card");
      const siteHeader = document.getElementById("site-header");
      const dashboard = document.getElementById("dashboard");
      const authForm = document.getElementById("auth-form");
      const emailInput = document.getElementById("email");
      const fullNameInput = document.getElementById("full-name");
      const passwordInput = document.getElementById("password");
      const passwordToggleButton = document.getElementById("password-visibility");
      const modeButtons = document.querySelectorAll("[data-auth-mode]");
      const fullNameField = document.getElementById("full-name-field");
      const authSubmitButton = document.getElementById("auth-submit");
      const authMessage = document.getElementById("auth-message");
      const rosterMessage = document.getElementById("roster-message");
      const groupMessage = document.getElementById("group-message");
      const joinButton = document.getElementById("join-btn");
      const leaveButton = document.getElementById("leave-btn");
      const onBusList = document.getElementById("on-bus");
      const offBusList = document.getElementById("off-bus");
      const breakOnList = document.getElementById("break-on");
      const breakOffList = document.getElementById("break-off");
      const breakJoinButton = document.getElementById("break-join-btn");
      const breakLeaveButton = document.getElementById("break-leave-btn");
      const breakMessage = document.getElementById("break-message");
      const dutyListsContainer = document.getElementById("duty-lists");
      const dutyMessage = document.getElementById("duty-message");
      const dutySelect = document.getElementById("duty-select");
      const dutySaveButton = document.getElementById("duty-save");
      const userEmailEl = document.getElementById("user-email");
      const signOutButton = document.getElementById("sign-out");
      const adminPanel = document.getElementById("admin-panel");
      const adminGroupsContainer = document.getElementById("admin-groups");
      const adminUserEmail = document.getElementById("admin-user-email");
      const adminSignOutButton = document.getElementById("admin-sign-out");

      let authMode = "signin";
      let currentUser = null;
      let currentGroupId = null;
      let currentProfile = { fullName: "" };
      let pendingIdentity = null;
      let rosterEntries = [];
      let rosterUnsubscribe = null;
      let groupUnsubscribe = null;
      let selfEntry = null;
      let isRosterMutating = false;
      let isPasswordVisible = false;
      let isBreakMutating = false;
      let isDutyMutating = false;
      let isAdmin = false;
      const adminRosterData = new Map();
      const adminRosterUnsubscribes = new Map();

      function toggleViews(isSignedIn) {
        if (isSignedIn) {
          authCard.classList.add("hidden");
          dashboard.classList.toggle("hidden", Boolean(isAdmin));
        } else {
          authCard.classList.remove("hidden");
          dashboard.classList.add("hidden");
        }
      }

      function setAuthMessage(message, isError = false) {
        authMessage.textContent = message;
        authMessage.classList.toggle("error", isError);
      }

      function setRosterMessage(message = "", isError = false) {
        if (!rosterMessage) return;
        rosterMessage.textContent = message;
        rosterMessage.classList.toggle("error", isError);
      }

      function setGroupMessage(message = "", isError = false) {
        if (!groupMessage) return;
        groupMessage.textContent = message;
        groupMessage.classList.toggle("error", isError);
      }

      function setBreakMessage(message = "", isError = false) {
        if (!breakMessage) return;
        breakMessage.textContent = message;
        breakMessage.classList.toggle("error", isError);
      }

      function setDutyMessage(message = "", isError = false) {
        if (!dutyMessage) return;
        dutyMessage.textContent = message;
        dutyMessage.classList.toggle("error", isError);
      }

      function isAdminAccount(user) {
        const email = typeof user === "string" ? user : user?.email;
        return Boolean(email && ADMIN_EMAILS.has(String(email).toLowerCase()));
      }

      function setAdminMode(enabled) {
        isAdmin = Boolean(enabled);
        if (adminPanel) {
          adminPanel.classList.toggle("hidden", !isAdmin);
        }
        if (isAdmin && adminUserEmail && currentUser) {
          adminUserEmail.textContent = currentUser.email;
        }
        if (!isAdmin) {
          stopAdminRosterWatchers();
          if (adminGroupsContainer) {
            adminGroupsContainer.innerHTML = "";
          }
        } else {
          renderAdminPanel();
        }
      }

      function setPasswordVisibility(visible) {
        if (!passwordInput) return;
        isPasswordVisible = Boolean(visible);
        passwordInput.type = isPasswordVisible ? "text" : "password";
        if (passwordToggleButton) {
          passwordToggleButton.textContent = isPasswordVisible ? "Hide" : "Show";
          passwordToggleButton.setAttribute("aria-pressed", String(isPasswordVisible));
        }
      }

      function setAuthMode(mode) {
        authMode = mode === "register" ? "register" : "signin";
        const needsFullName = authMode === "register";
        modeButtons.forEach((button) => {
          const isActive = button.dataset.authMode === authMode;
          button.classList.toggle("active", isActive);
          button.setAttribute("aria-pressed", String(isActive));
        });
        fullNameField.classList.toggle("hidden", !needsFullName);
        fullNameInput.required = needsFullName;
        authSubmitButton.textContent = needsFullName ? "Create Account" : "Sign In";
        if (needsFullName) {
          attemptFullNamePrefill();
        }
        setAuthMessage("");
        setPasswordVisibility(false);
      }

      function isValidGroupId(groupId) {
        return Boolean(groupId && GROUPS[groupId]);
      }

      function groupLabel(groupId) {
        return GROUPS[groupId] ?? groupId ?? "Unknown";
      }

      function sanitizeFullName(value) {
        return value ? value.replace(/\s+/g, " ").trim() : "";
      }

      function rememberFullName(email, fullName) {
        if (!email || !fullName) return;
        try {
          localStorage.setItem(`fullName:${email}`, fullName);
        } catch {
          /* ignore storage issues */
        }
      }

      function recallFullName(email) {
        if (!email) return "";
        try {
          return localStorage.getItem(`fullName:${email}`) ?? "";
        } catch {
          return "";
        }
      }

      function getCurrentFullName() {
        return (
          sanitizeFullName(currentProfile?.fullName) ||
          sanitizeFullName(pendingIdentity?.fullName) ||
          ""
        );
      }

      async function saveProfileFullName(user, fullName) {
        if (!user || !fullName) return;
        const profileRef = doc(db, "userProfiles", user.uid);
        try {
          await setDoc(
            profileRef,
            {
              fullName,
              email: user.email,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          currentProfile = { fullName };
        } catch (error) {
          console.error("Unable to save profile name", error);
          throw error;
        }
      }

      async function fetchProfile(user) {
        if (!user) return null;
        try {
          const snapshot = await getDoc(doc(db, "userProfiles", user.uid));
          if (snapshot.exists()) {
            return snapshot.data();
          }
        } catch (error) {
          console.error("Unable to load profile", error);
        }
        return null;
      }

      function toDate(value) {
        if (!value) return null;
        if (typeof value.toDate === "function") {
          try {
            return value.toDate();
          } catch {
            return null;
          }
        }
        const date = new Date(value);
        return Number.isNaN(date.getTime()) ? null : date;
      }

      function getTimestampValue(value) {
        const date = toDate(value);
        return date ? date.getTime() : Number.MAX_SAFE_INTEGER;
      }

      function formatTime(value) {
        const date = toDate(value);
        if (!date) return "--:--";
        try {
          return new Intl.DateTimeFormat("en-US", {
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          }).format(date);
        } catch {
          return "--:--";
        }
      }

      function currentResetDateKey() {
        try {
          const formatter = new Intl.DateTimeFormat("en-CA", {
            timeZone: RESET_TIMEZONE,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
          });
          return formatter.format(new Date());
        } catch {
          const today = new Date();
          const month = String(today.getMonth() + 1).padStart(2, "0");
          const day = String(today.getDate()).padStart(2, "0");
          return `${today.getFullYear()}-${month}-${day}`;
        }
      }

      function dateKeyFor(value) {
        const date = toDate(value);
        if (!date) return "";
        try {
          const formatter = new Intl.DateTimeFormat("en-CA", {
            timeZone: RESET_TIMEZONE,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
          });
          return formatter.format(date);
        } catch {
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          return `${date.getFullYear()}-${month}-${day}`;
        }
      }

      function isOnBusToday(entry) {
        if (!entry || !entry.isOnBus || !entry.joinedAt) return false;
        return dateKeyFor(entry.joinedAt) === currentResetDateKey();
      }

      function isOnDutyToday(entry) {
        if (!entry || !entry.dutyPlacement || !entry.dutyAssignedAt) return false;
        return dateKeyFor(entry.dutyAssignedAt) === currentResetDateKey();
      }

      function isOnBreakToday(entry) {
        if (!entry || !entry.isOnBreak || !entry.breakJoinedAt) return false;
        return dateKeyFor(entry.breakJoinedAt) === currentResetDateKey();
      }

      function dutyLabelFor(entry) {
        const id = entry?.dutyPlacement;
        if (!id) return "Not assigned";
        const found = DUTY_PLACES.find((place) => place.id === id);
        return found ? found.label : id;
      }

      function updateActionButtons() {
        if (!currentUser || !currentGroupId) {
          joinButton.disabled = true;
          leaveButton.disabled = true;
          if (breakJoinButton) breakJoinButton.disabled = true;
          if (breakLeaveButton) breakLeaveButton.disabled = true;
          return;
        }
        const entry =
          rosterEntries.find((record) => record.id === currentUser.uid) ?? selfEntry;
        const isOnBus = isOnBusToday(entry);
        joinButton.disabled = isRosterMutating || isOnBus;
        leaveButton.disabled = isRosterMutating || !isOnBus;

        const onBreak = isOnBreakToday(entry);
        if (breakJoinButton) {
          breakJoinButton.disabled =
            isBreakMutating || !isOnBus || onBreak;
        }
        if (breakLeaveButton) {
          breakLeaveButton.disabled =
            isBreakMutating || !isOnBus || !onBreak;
        }
      }

      function createListItem(entry, { showJoinedAt = false } = {}) {
        const li = document.createElement("li");

        const person = document.createElement("span");
        person.className = "person";

        const nameSpan = document.createElement("span");
        nameSpan.className = "person-name";
        nameSpan.textContent = entry.fullName ?? entry.email ?? "Unknown rider";
        person.appendChild(nameSpan);

        li.appendChild(person);

        if (showJoinedAt && entry.joinedAt) {
          const timeSpan = document.createElement("span");
          timeSpan.className = "time-badge";
          timeSpan.textContent = formatTime(entry.joinedAt);
          li.appendChild(timeSpan);
        }

        return li;
      }

      function createBreakListItem(entry, { showTime = true } = {}) {
        const li = document.createElement("li");

        const person = document.createElement("span");
        person.className = "person";

        const nameSpan = document.createElement("span");
        nameSpan.className = "person-name";
        nameSpan.textContent = entry.fullName ?? entry.email ?? "Unknown staff";
        person.appendChild(nameSpan);

        const duty = document.createElement("span");
        duty.className = "duty-tag";
        duty.textContent = dutyLabelFor(entry);
        person.appendChild(duty);

        li.appendChild(person);

        if (showTime && entry.breakJoinedAt) {
          const timeSpan = document.createElement("span");
          timeSpan.className = "time-badge";
          timeSpan.textContent = formatTime(entry.breakJoinedAt);
          li.appendChild(timeSpan);
        }

        return li;
      }

      function populateList(target, entries, emptyText, options = {}) {
        if (!entries.length) {
          target.innerHTML = `<li class="empty">${emptyText}</li>`;
          return;
        }
        const fragment = document.createDocumentFragment();
        entries.forEach((entry) => {
          fragment.appendChild(createListItem(entry, options));
        });
        target.replaceChildren(fragment);
      }

      function renderLists() {
        if (!currentUser) {
          onBusList.innerHTML = '<li class="empty">Sign in to see the roster.</li>';
          offBusList.innerHTML = '<li class="empty">Sign in to see the roster.</li>';
          updateActionButtons();
          if (breakOnList) {
            breakOnList.innerHTML =
              '<li class="empty">Sign in to see who is on break.</li>';
          }
          if (breakOffList) {
            breakOffList.innerHTML =
              '<li class="empty">Sign in to see who is not on break.</li>';
          }
          return;
        }

        if (!currentGroupId) {
          const awaiting = "Waiting for a group assignment.";
          onBusList.innerHTML = `<li class="empty">${awaiting}</li>`;
          offBusList.innerHTML = `<li class="empty">${awaiting}</li>`;
          updateActionButtons();
          if (breakOnList) {
            breakOnList.innerHTML = `<li class="empty">${awaiting}</li>`;
          }
          if (breakOffList) {
            breakOffList.innerHTML = `<li class="empty">${awaiting}</li>`;
          }
          return;
        }

        const onBusEntries = rosterEntries.filter((entry) => isOnBusToday(entry));
        const offBusEntries = rosterEntries.filter((entry) => !isOnBusToday(entry));

        const onBusSorted = [...onBusEntries].sort(
          (a, b) => getTimestampValue(a.joinedAt) - getTimestampValue(b.joinedAt)
        );
        const offBusSorted = [...offBusEntries].sort((a, b) =>
          (a.email ?? "").localeCompare(b.email ?? "", undefined, { sensitivity: "base" })
        );

        populateList(onBusList, onBusSorted, "Nobody is on the bus right now.", {
          showJoinedAt: true,
        });
        populateList(offBusList, offBusSorted, "Everyone is already on board.");
        updateActionButtons();
        renderBreakLists();
        renderDutyLists();
      }

      function renderBreakLists() {
        if (!breakOnList || !breakOffList) return;

        if (!currentUser) {
          breakOnList.innerHTML =
            '<li class="empty">Sign in to see who is on break.</li>';
          breakOffList.innerHTML =
            '<li class="empty">Sign in to see who is not on break.</li>';
          return;
        }

        if (!currentGroupId) {
          const awaiting = "Waiting for a group assignment.";
          breakOnList.innerHTML = `<li class="empty">${awaiting}</li>`;
          breakOffList.innerHTML = `<li class="empty">${awaiting}</li>`;
          return;
        }

        const onBreakEntries = rosterEntries.filter(
          (entry) => isOnBusToday(entry) && isOnBreakToday(entry)
        );
        const offBreakEntries = rosterEntries.filter(
          (entry) => isOnBusToday(entry) && !isOnBreakToday(entry)
        );

        const onSorted = [...onBreakEntries].sort(
          (a, b) => getTimestampValue(a.breakJoinedAt) - getTimestampValue(b.breakJoinedAt)
        );
        const offSorted = [...offBreakEntries].sort((a, b) =>
          (a.fullName ?? a.email ?? "").localeCompare(
            b.fullName ?? b.email ?? "",
            undefined,
            { sensitivity: "base" }
          )
        );

        if (!onSorted.length) {
          breakOnList.innerHTML =
            '<li class="empty">Nobody is on break right now.</li>';
        } else {
          const fragment = document.createDocumentFragment();
          onSorted.forEach((entry) => {
            fragment.appendChild(createBreakListItem(entry, { showTime: true }));
          });
          breakOnList.replaceChildren(fragment);
        }

        if (!offSorted.length) {
          breakOffList.innerHTML =
            '<li class="empty">Nobody is waiting to go on break.</li>';
        } else {
          const fragment = document.createDocumentFragment();
          offSorted.forEach((entry) => {
            fragment.appendChild(createBreakListItem(entry, { showTime: false }));
          });
          breakOffList.replaceChildren(fragment);
        }

        updateActionButtons();
      }

      function renderDutyLists() {
        if (!dutyListsContainer) return;

        if (!currentUser) {
          dutyListsContainer.innerHTML =
            '<p class="muted">Sign in to see duty placements.</p>';
          if (dutySelect) {
            dutySelect.value = "";
            dutySelect.disabled = true;
          }
          if (dutySaveButton) {
            dutySaveButton.disabled = true;
          }
          return;
        }

        if (!currentGroupId) {
          dutyListsContainer.innerHTML =
            '<p class="muted">Waiting for a group assignment.</p>';
          if (dutySelect) {
            dutySelect.value = "";
            dutySelect.disabled = true;
          }
          if (dutySaveButton) {
            dutySaveButton.disabled = true;
          }
          return;
        }

        const fragment = document.createDocumentFragment();
        const dutyBuckets = new Map();
        DUTY_PLACES.forEach((place) => {
          dutyBuckets.set(place.id, []);
        });

        const unassignedEntries = [];

        rosterEntries.forEach((entry) => {
          if (!entry || !isOnBusToday(entry)) return;
          const dutyId = entry.dutyPlacement;
          const isToday = dutyId && isOnDutyToday(entry) && dutyBuckets.has(dutyId);
          if (isToday) {
            dutyBuckets.get(dutyId).push(entry);
          } else {
            unassignedEntries.push(entry);
          }
        });

        DUTY_PLACES.forEach((place) => {
          const column = document.createElement("div");
          column.className = "list-column";

          const header = document.createElement("div");
          header.className = "list-header";

          const title = document.createElement("h2");
          title.textContent = place.label;
          header.appendChild(title);
          column.appendChild(header);

          const list = document.createElement("ul");
          list.className = "status-list";

          const entries = dutyBuckets.get(place.id) ?? [];
          const sorted = [...entries].sort((a, b) =>
            (a.fullName ?? a.email ?? "").localeCompare(
              b.fullName ?? b.email ?? "",
              undefined,
              { sensitivity: "base" }
            )
          );

          populateList(list, sorted, `Nobody assigned to ${place.label} today.`);
          column.appendChild(list);
          fragment.appendChild(column);
        });

        const unassignedColumn = document.createElement("div");
        unassignedColumn.className = "list-column";

        const unassignedHeader = document.createElement("div");
        unassignedHeader.className = "list-header";

        const unassignedTitle = document.createElement("h2");
        unassignedTitle.textContent = "Not assigned";
        unassignedHeader.appendChild(unassignedTitle);
        unassignedColumn.appendChild(unassignedHeader);

        const unassignedList = document.createElement("ul");
        unassignedList.className = "status-list";

        const unassignedSorted = [...unassignedEntries].sort((a, b) =>
          (a.fullName ?? a.email ?? "").localeCompare(
            b.fullName ?? b.email ?? "",
            undefined,
            { sensitivity: "base" }
          )
        );

        populateList(
          unassignedList,
          unassignedSorted,
          "Everyone has a duty today."
        );
        unassignedColumn.appendChild(unassignedList);
        fragment.appendChild(unassignedColumn);

        dutyListsContainer.replaceChildren(fragment);
        syncDutyControls();
      }

      function renderAdminPanel() {
        if (!adminGroupsContainer) return;
        if (!isAdmin) {
          adminGroupsContainer.innerHTML = "";
          return;
        }

        const fragment = document.createDocumentFragment();
        const groupIds = Object.keys(GROUPS);
        if (!groupIds.length) {
          adminGroupsContainer.innerHTML = '<p class="muted">No groups configured.</p>';
          return;
        }

        groupIds.forEach((groupId) => {
          const card = document.createElement("div");
          card.className = "admin-group-card";

          const title = document.createElement("h3");
          title.textContent = `Group ${groupLabel(groupId)}`;
          card.appendChild(title);

          const roster = adminRosterData.get(groupId) ?? [];
          const onEntries = roster.filter((entry) => isOnBusToday(entry));
          const offEntries = roster.filter((entry) => !isOnBusToday(entry));

          const onLabel = document.createElement("p");
          onLabel.className = "eyebrow";
          onLabel.textContent = "On the bus";
          card.appendChild(onLabel);

          const onList = document.createElement("ul");
          onList.className = "status-list";
          const onSorted = [...onEntries].sort(
            (a, b) => getTimestampValue(a.joinedAt) - getTimestampValue(b.joinedAt)
          );
          populateList(onList, onSorted, "Nobody is on the bus right now.", { showJoinedAt: true });
          card.appendChild(onList);

          const divider = document.createElement("div");
          divider.className = "admin-group-divider";
          card.appendChild(divider);

          const offLabel = document.createElement("p");
          offLabel.className = "eyebrow";
          offLabel.textContent = "Not on the bus";
          card.appendChild(offLabel);

          const offList = document.createElement("ul");
          offList.className = "status-list";
          const offSorted = [...offEntries].sort((a, b) =>
            (a.email ?? "").localeCompare(b.email ?? "", undefined, { sensitivity: "base" })
          );
          populateList(offList, offSorted, "Everybody is already on board.");
          card.appendChild(offList);

          fragment.appendChild(card);
        });

        adminGroupsContainer.replaceChildren(fragment);
      }

      function startAdminRosterWatchers() {
        if (!isAdmin) return;
        stopAdminRosterWatchers();
        Object.keys(GROUPS).forEach((groupId) => {
          const rosterRef = collection(db, "groups", groupId, "busRoster");
          const unsubscribe = onSnapshot(
            rosterRef,
            (snapshot) => {
              const roster = snapshot.docs.map((docSnap) => ({
                id: docSnap.id,
                ...docSnap.data(),
              }));
              adminRosterData.set(groupId, roster);
              renderAdminPanel();
            },
            (error) => {
              console.error(`Admin roster listener failed for group ${groupId}`, error);
            }
          );
          adminRosterUnsubscribes.set(groupId, unsubscribe);
        });
        renderAdminPanel();
      }

      function stopAdminRosterWatchers() {
        adminRosterUnsubscribes.forEach((unsubscribe) => {
          try {
            unsubscribe();
          } catch {
            /* ignore */
          }
        });
        adminRosterUnsubscribes.clear();
        adminRosterData.clear();
        renderAdminPanel();
      }

      async function ensureRosterEntry(user, groupId) {
        if (!user || !groupId) return;
        const ref = doc(db, "groups", groupId, "busRoster", user.uid);
        const fullName = getCurrentFullName() || user.email;
        try {
          const snapshot = await getDoc(ref);
          if (!snapshot.exists()) {
            const seed = {
              email: user.email,
              fullName,
              isOnBus: false,
              joinedAt: null,
              updatedAt: serverTimestamp(),
            };
            await setDoc(ref, seed);
            selfEntry = { id: user.uid, ...seed };
          } else {
            const data = snapshot.data();
            selfEntry = { id: user.uid, ...data };
            if (fullName && data.fullName !== fullName) {
              await setDoc(
                ref,
                {
                  fullName,
                  email: user.email,
                  updatedAt: serverTimestamp(),
                },
                { merge: true }
              );
              selfEntry.fullName = fullName;
            }
          }
          updateActionButtons();
        } catch (error) {
          console.error("Unable to prepare roster entry", error);
          setRosterMessage("Unable to prepare your roster slot.", true);
        }
      }

      function startRosterSubscription(groupId) {
        if (!groupId) return;
        stopRosterSubscription();
        const rosterRef = collection(db, "groups", groupId, "busRoster");
        rosterUnsubscribe = onSnapshot(
          rosterRef,
          (snapshot) => {
            rosterEntries = snapshot.docs.map((docSnap) => ({
              id: docSnap.id,
              ...docSnap.data(),
            }));
            if (currentUser) {
              const latestSelf = rosterEntries.find((entry) => entry.id === currentUser.uid);
              if (latestSelf) {
                selfEntry = latestSelf;
              }
            }
            renderLists();
          },
          (error) => {
            console.error("Roster listener error", error);
            setRosterMessage("Live roster updates paused. Refresh the page.", true);
          }
        );
      }

      function stopRosterSubscription() {
        if (rosterUnsubscribe) {
          rosterUnsubscribe();
          rosterUnsubscribe = null;
        }
        rosterEntries = [];
        selfEntry = null;
        renderLists();
      }

      function startGroupWatcher(user) {
        stopGroupWatcher();
        if (!user) return;
        const groupRef = doc(db, "userGroups", user.uid);
        groupUnsubscribe = onSnapshot(
          groupRef,
          (snapshot) => {
            handleGroupSnapshot(snapshot).catch((error) => {
              console.error("Group handling failed", error);
              setGroupMessage("Unable to load your group.", true);
            });
          },
          (error) => {
            console.error("Group listener error", error);
            currentGroupId = null;
            setGroupMessage("Unable to load your group.", true);
            stopRosterSubscription();
            updateActionButtons();
          }
        );
      }

      function stopGroupWatcher() {
        if (groupUnsubscribe) {
          groupUnsubscribe();
          groupUnsubscribe = null;
        }
      }

      async function handleGroupSnapshot(snapshot) {
        if (!currentUser) return;
        if (!snapshot.exists()) {
          currentGroupId = null;
          setGroupMessage("No group assigned. Contact the owner.", true);
          stopRosterSubscription();
          updateActionButtons();
          return;
        }
        const data = snapshot.data();
        const groupId = data.groupId;
        if (!isValidGroupId(groupId)) {
          currentGroupId = null;
          setGroupMessage("Invalid group assignment. Contact the owner.", true);
          stopRosterSubscription();
          updateActionButtons();
          return;
        }
        if (groupId === currentGroupId) {
          setGroupMessage(`Group: ${groupLabel(groupId)}`);
          return;
        }
        currentGroupId = groupId;
        setGroupMessage(`Group: ${groupLabel(groupId)}`);
        setRosterMessage("");
        stopRosterSubscription();
        await ensureRosterEntry(currentUser, groupId);
        startRosterSubscription(groupId);
      }

      function syncDutyControls() {
        if (!dutySelect) return;

        if (!currentUser || !currentGroupId) {
          dutySelect.value = "";
          dutySelect.disabled = true;
          if (dutySaveButton) {
            dutySaveButton.disabled = true;
          }
          return;
        }

        const entry =
          rosterEntries.find((record) => record.id === currentUser.uid) ?? selfEntry;
        const dutyId =
          entry && isOnDutyToday(entry) && entry.dutyPlacement ? entry.dutyPlacement : "";

        dutySelect.value = dutyId;
        const onBus = entry && isOnBusToday(entry);
        dutySelect.disabled = !onBus;
        if (dutySaveButton) {
          dutySaveButton.disabled = !onBus || isDutyMutating;
        }
      }

      async function updateBusStatus(targetState) {
        if (!currentUser || !currentGroupId || isRosterMutating) {
          if (!currentGroupId) {
            setRosterMessage("You need a group before toggling the bus.", true);
          }
          return;
        }
        isRosterMutating = true;
        updateActionButtons();
        setRosterMessage(targetState ? "Joining the bus…" : "Leaving the bus…");

        const fullName = getCurrentFullName() || currentUser.email;
        const optimisticEntry = {
          id: currentUser.uid,
          email: currentUser.email,
          fullName,
          isOnBus: targetState,
          joinedAt: targetState ? new Date() : null,
        };
        if (!targetState) {
          optimisticEntry.isOnBreak = false;
          optimisticEntry.breakJoinedAt = null;
        }
        const index = rosterEntries.findIndex((entry) => entry.id === currentUser.uid);
        if (index >= 0) {
          rosterEntries[index] = { ...rosterEntries[index], ...optimisticEntry };
        } else {
          rosterEntries = [...rosterEntries, optimisticEntry];
        }
        selfEntry = optimisticEntry;
        renderLists();

        try {
          const payload = {
            email: currentUser.email,
            fullName,
            isOnBus: targetState,
            joinedAt: targetState ? serverTimestamp() : null,
            updatedAt: serverTimestamp(),
          };
          if (!targetState) {
            payload.isOnBreak = false;
            payload.breakJoinedAt = null;
          }

          await setDoc(
            doc(db, "groups", currentGroupId, "busRoster", currentUser.uid),
            payload,
            { merge: true }
          );
          setRosterMessage(targetState ? "You are on the bus." : "You left the bus.");
        } catch (error) {
          console.error("Roster update failed", error);
          setRosterMessage("Update failed. Please try again.", true);
        } finally {
          isRosterMutating = false;
          updateActionButtons();
        }
      }

      async function updateBreakStatus(targetState) {
        if (!currentUser || !currentGroupId || isBreakMutating) {
          if (!currentGroupId) {
            setBreakMessage("You need a group before starting a break.", true);
          }
          return;
        }

        const entry =
          rosterEntries.find((record) => record.id === currentUser.uid) ?? selfEntry;
        if (!isOnBusToday(entry)) {
          setBreakMessage("You must be on the bus to start a break.", true);
          return;
        }

        isBreakMutating = true;
        updateActionButtons();
        setBreakMessage(targetState ? "Starting break…" : "Ending break…");

        const fullName = getCurrentFullName() || currentUser.email;
        const optimisticEntry = {
          id: currentUser.uid,
          email: currentUser.email,
          fullName,
          ...entry,
          isOnBreak: targetState,
          breakJoinedAt: targetState ? new Date() : null,
        };

        const index = rosterEntries.findIndex((item) => item.id === currentUser.uid);
        if (index >= 0) {
          rosterEntries[index] = { ...rosterEntries[index], ...optimisticEntry };
        } else {
          rosterEntries = [...rosterEntries, optimisticEntry];
        }
        selfEntry = optimisticEntry;
        renderBreakLists();

        try {
          await setDoc(
            doc(db, "groups", currentGroupId, "busRoster", currentUser.uid),
            {
              email: currentUser.email,
              fullName,
              isOnBreak: targetState,
              breakJoinedAt: targetState ? serverTimestamp() : null,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          setBreakMessage(
            targetState ? "You are on break." : "You are back from break."
          );
        } catch (error) {
          console.error("Break update failed", error);
          setBreakMessage("Unable to update break status. Please try again.", true);
        } finally {
          isBreakMutating = false;
          updateActionButtons();
        }
      }

      async function updateDutyPlacement(targetDutyId) {
        if (!currentUser || !currentGroupId || isDutyMutating) {
          if (!currentGroupId) {
            setDutyMessage("You need a group before setting duty.", true);
          }
          return;
        }

        const entry =
          rosterEntries.find((record) => record.id === currentUser.uid) ?? selfEntry;
        if (!isOnBusToday(entry)) {
          setDutyMessage("You must be on the bus to set duty.", true);
          return;
        }

        isDutyMutating = true;
        syncDutyControls();
        setDutyMessage("Updating duty…");

        const fullName = getCurrentFullName() || currentUser.email;
        const ref = doc(db, "groups", currentGroupId, "busRoster", currentUser.uid);

        const payload = {
          email: currentUser.email,
          fullName,
          updatedAt: serverTimestamp(),
        };

        if (!targetDutyId) {
          payload.dutyPlacement = null;
          payload.dutyAssignedAt = null;
        } else {
          payload.dutyPlacement = targetDutyId;
          payload.dutyAssignedAt = serverTimestamp();
        }

        try {
          await setDoc(ref, payload, { merge: true });

          const existing =
            rosterEntries.find((entry) => entry.id === currentUser.uid) ?? selfEntry;

          const updatedEntry = {
            id: currentUser.uid,
            email: currentUser.email,
            fullName,
            ...existing,
            dutyPlacement: targetDutyId || null,
            dutyAssignedAt: targetDutyId ? new Date() : null,
          };

          selfEntry = updatedEntry;
          const index = rosterEntries.findIndex((entry) => entry.id === currentUser.uid);
          if (index >= 0) {
            rosterEntries[index] = updatedEntry;
          } else {
            rosterEntries = [...rosterEntries, updatedEntry];
          }

          renderDutyLists();
          setDutyMessage("Duty updated.");
        } catch (error) {
          console.error("Duty update failed", error);
          setDutyMessage("Unable to update duty. Please try again.", true);
        } finally {
          isDutyMutating = false;
          syncDutyControls();
        }
      }

      function attemptFullNamePrefill() {
        if (authMode !== "register") return;
        const suggestion = recallFullName(emailInput.value.trim());
        if (suggestion && !fullNameInput.value.trim()) {
          fullNameInput.value = suggestion;
        }
      }

      modeButtons.forEach((button) => {
        button.addEventListener("click", () => setAuthMode(button.dataset.authMode));
      });

      setAuthMode("signin");

      emailInput.addEventListener("blur", attemptFullNamePrefill);
      emailInput.addEventListener("change", attemptFullNamePrefill);

      if (passwordToggleButton) {
        passwordToggleButton.addEventListener("click", () => {
          setPasswordVisibility(!isPasswordVisible);
          passwordInput?.focus();
        });
      }

      if (dutySaveButton && dutySelect) {
        dutySaveButton.addEventListener("click", () => {
          const selected = dutySelect.value || "";
          updateDutyPlacement(selected);
        });
      }

      if (breakJoinButton) {
        breakJoinButton.addEventListener("click", () => {
          updateBreakStatus(true);
        });
      }

      if (breakLeaveButton) {
        breakLeaveButton.addEventListener("click", () => {
          updateBreakStatus(false);
        });
      }

      authForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const email = emailInput.value.trim();
        const isRegister = authMode === "register";
        const fullName = isRegister ? sanitizeFullName(fullNameInput.value) : "";
        if (isRegister) {
          fullNameInput.value = fullName;
        }
        const password = passwordInput.value.trim();

        if (!email) {
          setAuthMessage("Enter an email address.", true);
          return;
        }

        if (!password) {
          setAuthMessage("Enter a password.", true);
          return;
        }

        if (isRegister && !fullName) {
          setAuthMessage("Enter your full name.", true);
          return;
        }

        if (isRegister) {
          pendingIdentity = { email, fullName };
          rememberFullName(email, fullName);
        } else {
          pendingIdentity = null;
        }

        try {
          if (isRegister) {
            setAuthMessage("Creating your account…");
            await createUserWithEmailAndPassword(auth, email, password);
            setAuthMessage("Account created. Signing you in…");
          } else {
            setAuthMessage("Signing you in…");
            await signInWithEmailAndPassword(auth, email, password);
            setAuthMessage("Signed in.");
          }
        } catch (error) {
          const friendly =
            typeof error?.code === "string"
              ? error.code.replace("auth/", "").replace(/-/g, " ")
              : "Something went wrong. Try again.";
          setAuthMessage(friendly, true);
          pendingIdentity = null;
        }
      });

      joinButton.addEventListener("click", () => updateBusStatus(true));
      leaveButton.addEventListener("click", () => updateBusStatus(false));

      signOutButton.addEventListener("click", async () => {
        try {
          await signOut(auth);
          setAuthMessage("Signed out.");
        } catch {
          setAuthMessage("Unable to sign out. Try again.", true);
        }
      });
      if (adminSignOutButton) {
        adminSignOutButton.addEventListener("click", () => signOutButton.click());
      }

      onAuthStateChanged(auth, async (user) => {
        currentUser = user;
        const adminStatus = user ? isAdminAccount(user) : false;
        setAdminMode(adminStatus);

        if (user) {
          userEmailEl.textContent = user.email;
          setRosterMessage("");
          setGroupMessage(adminStatus ? "Admin overview" : "Looking up your group…");
          try {
            if (pendingIdentity && pendingIdentity.email === user.email) {
              await saveProfileFullName(user, pendingIdentity.fullName);
              rememberFullName(user.email, pendingIdentity.fullName);
            } else {
              const profile = await fetchProfile(user);
              currentProfile = profile?.fullName
                ? { fullName: sanitizeFullName(profile.fullName) }
                : { fullName: "" };
              if (!currentProfile.fullName) {
                const suggestion = recallFullName(user.email);
                if (suggestion) {
                  currentProfile.fullName = suggestion;
                  rememberFullName(user.email, suggestion);
                } else {
                  setAuthMessage("Add your full name when signing in next time.", true);
                }
              } else {
                rememberFullName(user.email, currentProfile.fullName);
              }
            }
          } catch {
            setAuthMessage("Unable to sync your full name. Try again.", true);
          } finally {
            pendingIdentity = null;
          }

          if (adminStatus) {
            startAdminRosterWatchers();
            stopGroupWatcher();
            stopRosterSubscription();
            currentGroupId = null;
          } else {
            stopAdminRosterWatchers();
            startGroupWatcher(user);
          }
        } else {
          userEmailEl.textContent = "—";
          setRosterMessage("");
          setGroupMessage("");
          currentGroupId = null;
          currentProfile = { fullName: "" };
          pendingIdentity = null;
          stopGroupWatcher();
          stopRosterSubscription();
          stopAdminRosterWatchers();
          setAdminMode(false);
        }

        toggleViews(Boolean(user));
        renderLists();
        renderAdminPanel();
        document.body.classList.remove("app-loading");
      });

      renderLists();
    </script>
  </body>
</html>
