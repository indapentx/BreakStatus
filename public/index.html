<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Trend ISG</title>
    <link rel="icon" type="image/png" sizes="512x512" href="indapentx.png" />
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --bg: #ffffff;
        --surface: #f4f4f4;
        --card: #ffffff;
        --text: #111111;
        --subtle: #6b6b6b;
        --border: #e3e3e3;
        --accent: #111111;
      }

      * {
        box-sizing: border-box;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      body {
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        margin: 0;
        padding: 2rem 1.5rem 3rem;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        justify-content: center;
      }

      main {
        width: min(960px, 100%);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      header {
        text-align: left;
      }

      h1 {
        margin: 0 0 0.35rem;
        font-size: clamp(2rem, 4vw, 2.5rem);
        letter-spacing: -0.02em;
      }

      header p {
        margin: 0;
        color: var(--subtle);
        max-width: 52ch;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 20px;
        padding: 1.75rem;
        box-shadow: 0 20px 40px rgba(17, 17, 17, 0.03);
      }

      .auth-card form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .auth-toggle {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.35rem;
        background: var(--surface);
        padding: 0.25rem;
        border-radius: 999px;
        border: 1px solid var(--border);
      }

      .auth-toggle button {
        border: none;
        background: transparent;
        color: var(--subtle);
        font-weight: 600;
        border-radius: 999px;
        padding: 0.65rem 0.5rem;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .auth-toggle button.active {
        background: var(--card);
        color: var(--text);
        box-shadow: 0 6px 12px rgba(17, 17, 17, 0.08);
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--subtle);
      }

      input {
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0.85rem 1.1rem;
        font-size: 1rem;
        background: var(--surface);
        color: var(--text);
      }

      input:focus-visible {
        outline: 2px solid var(--text);
        outline-offset: 2px;
      }

      select {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 0.85rem 1rem;
        font-size: 1rem;
        background: var(--surface);
        color: var(--text);
        min-width: 220px;
      }

      select:focus-visible {
        outline: 2px solid var(--text);
        outline-offset: 2px;
      }

      .form-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 0.85rem 1.4rem;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        background: var(--accent);
        color: var(--bg);
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      button.ghost {
        background: transparent;
        color: var(--text);
        border: 1px solid var(--border);
      }

      button.confirm {
        background: #b3261e;
        color: #ffffff;
        border-color: #b3261e;
      }

      button.ghost.confirm {
        border-color: #b3261e;
      }

      button:disabled {
        opacity: 0.35;
        cursor: not-allowed;
      }

      button:not(:disabled):hover {
        opacity: 0.9;
      }

      .muted {
        color: var(--subtle);
        font-size: 0.9rem;
        margin: 0;
        min-height: 1.25rem;
      }

      .muted:empty {
        display: none;
      }

      .field-hint {
        font-size: 0.8rem;
        color: var(--subtle);
      }

      #auth-message {
        margin-top: 1rem;
      }

      .full-name-field.hidden {
        display: none;
      }

      .password-input {
        position: relative;
      }

      .password-input input {
        width: 100%;
        padding-right: 4.75rem;
      }

      .password-visibility {
        position: absolute;
        right: 0.35rem;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        color: var(--text);
        padding: 0.35rem 0.75rem;
        font-size: 0.85rem;
        font-weight: 600;
        border: none;
      }

      .password-visibility:hover {
        opacity: 0.7;
      }

      .password-visibility:focus-visible {
        outline: 2px solid var(--text);
        outline-offset: 3px;
      }

      .muted.error {
        color: #b3261e;
      }

      .dashboard {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .user-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .role-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 1rem;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 1rem;
        background: var(--surface);
      }

      .role-meta {
        flex: 1 1 200px;
        min-width: 200px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 0.2rem;
      }

      .role-current {
        margin: 0;
        font-size: 1.1rem;
        letter-spacing: -0.01em;
        font-weight: 600;
      }

      .role-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.65rem;
        align-items: center;
      }

      .role-actions button {
        white-space: nowrap;
      }


      .eyebrow {
        text-transform: uppercase;
        font-size: 0.75rem;
        letter-spacing: 0.15em;
        color: var(--subtle);
        margin: 0;
      }

      .user-email {
        margin: 0.25rem 0 0;
        font-size: 1.35rem;
        font-weight: 600;
      }

      .lists {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1rem;
      }

      .list-column {
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1.2rem;
        background: var(--surface);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .list-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
      }

      h2 {
        margin: 0;
        font-size: 1.1rem;
        letter-spacing: -0.01em;
      }

      .status-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: stretch;
      }

      .status-list li {
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--card);
        padding: 0.9rem 1rem;
        font-weight: 500;
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        align-items: center;
        width: 100%;
        min-height: 68px;
      }

      .status-list .empty {
        color: var(--subtle);
        font-weight: 400;
        font-size: 0.95rem;
        justify-content: flex-start;
      }

      .person {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
      }

      .person-name {
        font-weight: 600;
      }

      .person-email {
        font-size: 0.85rem;
        color: var(--subtle);
        font-weight: 400;
      }

      .person-role {
        font-size: 0.85rem;
        color: var(--subtle);
        font-weight: 500;
      }

      .time-badge {
        font-size: 0.8rem;
        font-weight: 500;
        color: var(--subtle);
      }

      .hidden {
        display: none;
      }

      .admin-panel {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .admin-panel.hidden {
        display: none;
      }

      .admin-groups {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1rem;
      }

      .admin-group-card {
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1rem;
        background: var(--surface);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .admin-group-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .admin-toggle {
        padding: 0.45rem 0.9rem;
        font-size: 0.85rem;
      }

      .admin-group-card h3 {
        margin: 0;
        letter-spacing: -0.01em;
        text-transform: capitalize;
      }

      .admin-group-card .status-list {
        background: transparent;
      }

      .admin-group-body {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .admin-group-card.minimized {
        opacity: 0.9;
      }

      .admin-group-card.minimized .admin-group-body {
        display: none;
      }

      .admin-group-divider {
        height: 1px;
        width: 100%;
        background: var(--border);
      }

      .admin-logs {
        margin-top: 1rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .logs-header {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .logs-footer {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        margin-top: 0.75rem;
        align-items: flex-start;
      }

      .logs-heading {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .logs-actions {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
        width: 100%;
      }

      .log-reset-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }

      .log-group-select {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .log-option {
        border: 1px solid var(--border);
        background: var(--surface);
        border-radius: 999px;
        padding: 0.35rem 0.75rem;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-weight: 600;
        font-size: 0.9rem;
      }

      .log-option input {
        margin: 0;
      }

      .log-table {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 1rem;
      }

      .log-card {
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1rem;
        background: var(--surface);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .log-card.minimized {
        opacity: 0.9;
      }

      .log-card.minimized .log-card-body {
        display: none;
      }

      .log-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .log-card h3 {
        margin: 0;
        letter-spacing: -0.01em;
        text-transform: capitalize;
      }

      .log-card table {
        width: 100%;
        border-collapse: collapse;
      }

      .log-card th,
      .log-card td {
        text-align: left;
        padding: 0.45rem 0.25rem;
        border-bottom: 1px solid var(--border);
      }

      .log-card th {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: var(--subtle);
      }

      .log-card tr:last-child td {
        border-bottom: none;
      }

      .log-empty {
        color: var(--subtle);
        margin: 0.25rem 0;
        font-size: 0.95rem;
      }

      body.app-loading {
        position: relative;
      }

      body.app-loading main {
        visibility: hidden;
      }

      body.app-loading::before {
        content: "Loading…";
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--bg);
        color: var(--subtle);
        font-size: 0.95rem;
      }

      @media (max-width: 640px) {
        body {
          padding: 0.9rem;
        }

        main {
          gap: 1rem;
        }

        .card {
          padding: 1.25rem;
        }

        .lists {
          gap: 0.75rem;
        }

        .list-column {
          padding: 0.9rem;
          border-radius: 14px;
        }

        .form-actions {
          flex-direction: column;
        }

        .user-row {
          flex-direction: column;
          align-items: flex-start;
        }

        .role-actions {
          width: 100%;
        }

        .log-card table,
        .log-card tbody {
          display: block;
          width: 100%;
        }

        .log-card thead {
          display: none;
        }

        .log-card tr {
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 0.4rem;
          padding: 0.75rem 0;
          border-bottom: 1px solid var(--border);
        }

        .log-card tr:last-child {
          border-bottom: none;
        }

        .log-card td {
          display: flex;
          justify-content: space-between;
          align-items: flex-start;
          gap: 0.75rem;
          padding: 0;
          border: 0;
          width: 100%;
          font-size: 0.95rem;
          line-height: 1.3;
        }

        .log-card td::before {
          content: attr(data-label);
          font-size: 0.78rem;
          text-transform: uppercase;
          letter-spacing: 0.08em;
          color: var(--subtle);
          font-weight: 700;
        }
      }
    </style>
  </head>
  <body class="app-loading">
    <main>
      <header id="site-header">
        <h1>Break Status</h1>
        <p>Made by Furkan Öztürk for Trend ISG.</p>
      </header>

      <section class="card auth-card" id="auth-card">
        <form id="auth-form" autocomplete="on">
          <div class="auth-toggle" role="tablist" aria-label="Authentication mode">
            <button type="button" data-auth-mode="signin" class="active" aria-pressed="true">
              Sign In
            </button>
            <button type="button" data-auth-mode="register" aria-pressed="false">
              Create Account
            </button>
          </div>
          <label>
            Email
            <input type="email" id="email" name="email" placeholder="you@email.com" required />
          </label>
          <div class="full-name-field hidden" id="full-name-field">
            <label>
              Full name
              <input
                type="text"
                id="full-name"
                name="fullName"
                placeholder="Saul Goodman"
                autocomplete="name"
              />
            </label>
          </div>
          <label>
            Password
            <div class="password-input">
              <input
                type="password"
                id="password"
                name="password"
                minlength="6"
                placeholder="Minimum 6 characters"
                required
              />
              <button
                type="button"
                class="password-visibility"
                id="password-visibility"
                aria-pressed="false"
              >
                Show
              </button>
            </div>
          </label>
        <div class="form-actions">
          <button type="submit" id="auth-submit">Sign In</button>
        </div>
      </form>
        <p class="muted" id="auth-message">Use your credentials to access the break list.</p>
      </section>

      <section class="card dashboard hidden" id="dashboard">
        <div class="user-row">
          <div>
            <p class="eyebrow">Signed in as</p>
            <p class="user-email" id="user-email">—</p>
          </div>
          <button class="ghost" id="sign-out">Sign Out</button>
        </div>

        <div class="role-row" id="role-row">
          <div class="role-meta">
            <h2 class="role-current" id="role-current">No role selected</h2>
            <p class="muted" id="role-message"></p>
          </div>
          <div class="role-actions">
            <label class="sr-only" for="role-select">Choose your role</label>
            <select id="role-select">
              <option value="">Choose a role…</option>
            </select>
            <button type="button" id="role-save">Update role</button>
          </div>
        </div>

        <div class="lists">
          <div class="list-column">
            <div class="list-header">
              <h2>On break</h2>
              <button id="leave-btn" class="ghost" type="button" disabled>Return</button>
            </div>
            <ul class="status-list" id="on-break">
              <li class="empty">Sign in to see the break list.</li>
            </ul>
          </div>
          <div class="list-column">
            <div class="list-header">
              <h2>Working</h2>
              <button id="join-btn" type="button" disabled>Start break</button>
            </div>
            <ul class="status-list" id="off-break">
              <li class="empty">Sign in to see the break list.</li>
            </ul>
          </div>
        </div>
        <div class="lists">
          <div class="list-column">
            <div class="list-header">
              <h2>On meal break</h2>
              <button id="meal-leave-btn" class="ghost" type="button" disabled>End meal</button>
            </div>
            <ul class="status-list" id="on-meal-break">
              <li class="empty">Sign in to see the meal break list.</li>
            </ul>
          </div>
          <div class="list-column">
            <div class="list-header">
              <h2>Not on meal break</h2>
              <button id="meal-join-btn" type="button" disabled>Start meal</button>
            </div>
            <ul class="status-list" id="off-meal-break">
              <li class="empty">Sign in to see the meal break list.</li>
            </ul>
          </div>
        </div>
        <p class="muted" id="roster-message"></p>
        <p class="muted" id="group-message"></p>
      </section>

      <section class="card admin-panel hidden" id="admin-panel">
        <div class="user-row">
          <div>
            <p class="eyebrow">Staff view</p>
            <p class="user-email" id="admin-user-email">—</p>
          </div>
          <button class="ghost" id="admin-sign-out">Sign Out</button>
        </div>
        <div class="admin-groups" id="admin-groups">
          <p class="muted">Loading group data…</p>
        </div>
        <div class="admin-logs" id="admin-logs">
          <div class="logs-header">
            <div class="logs-heading">
              <p class="eyebrow">Break logs</p>
            </div>
          </div>
          <div class="log-table" id="log-table">
            <p class="muted">Loading logs…</p>
          </div>
          <div class="logs-footer">
            <div class="logs-actions">
              <div class="log-group-select" id="log-group-select" aria-label="Select groups to reset">
                <p class="muted">Loading groups…</p>
              </div>
              <div class="log-reset-actions">
                <button class="ghost" type="button" id="reset-selected-logs" disabled>
                  Reset selected groups
                </button>
                <button type="button" id="reset-all-logs">Reset all</button>
              </div>
            </div>
            <p class="muted hidden" id="logs-message"></p>
          </div>
        </div>
      </section>
    </main>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
      import {
        getAuth,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        createUserWithEmailAndPassword,
        signOut,
      } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
      import {
        getFirestore,
        doc,
        setDoc,
        getDoc,
        getDocs,
        collection,
        onSnapshot,
        serverTimestamp,
        writeBatch,
        runTransaction,
      } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDHZz5fVOTvnokTuTUjNSC5QSiC7mFxyZM",
        authDomain: "trend-isg.firebaseapp.com",
        projectId: "trend-isg",
        storageBucket: "trend-isg.firebasestorage.app",
        messagingSenderId: "751472868865",
        appId: "1:751472868865:web:eb6702b74236d19913ca00",
      };

      const GROUPS = Object.freeze({
        A: "A",
        B: "B",
        C: "C",
        D: "D",
      });

      const ROLE_OPTIONS = Object.freeze([
        { id: "international-departures", label: "International Departures" },
        { id: "domestic-departures", label: "Domestic Departures" },
        { id: "management-office", label: "Management Office" },
        { id: "e-passport", label: "E-passport" },
        { id: "e-passport-arrivals", label: "E-passport (Arrivals)" },
        { id: "bus-gate", label: "Bus Gate" },
      ]);

      const ADMIN_EMAILS = new Set([
        "furkan.ozturk@gmail.com",
      ]);
      
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);
      const RESET_TIMEZONE = "Europe/Istanbul";

      const authCard = document.getElementById("auth-card");
      const dashboard = document.getElementById("dashboard");
      const authForm = document.getElementById("auth-form");
      const emailInput = document.getElementById("email");
      const fullNameInput = document.getElementById("full-name");
      const passwordInput = document.getElementById("password");
      const passwordToggleButton = document.getElementById("password-visibility");
      const modeButtons = document.querySelectorAll("[data-auth-mode]");
      const fullNameField = document.getElementById("full-name-field");
      const authSubmitButton = document.getElementById("auth-submit");
      const authMessage = document.getElementById("auth-message");
      const rosterMessage = document.getElementById("roster-message");
      const groupMessage = document.getElementById("group-message");
      const joinButton = document.getElementById("join-btn");
      const leaveButton = document.getElementById("leave-btn");
      const onBreakList = document.getElementById("on-break");
      const offBreakList = document.getElementById("off-break");
      const mealJoinButton = document.getElementById("meal-join-btn");
      const mealLeaveButton = document.getElementById("meal-leave-btn");
      const onMealBreakList = document.getElementById("on-meal-break");
      const offMealBreakList = document.getElementById("off-meal-break");
      const userEmailEl = document.getElementById("user-email");
      const signOutButton = document.getElementById("sign-out");
      const adminPanel = document.getElementById("admin-panel");
      const adminGroupsContainer = document.getElementById("admin-groups");
      const adminUserEmail = document.getElementById("admin-user-email");
      const adminSignOutButton = document.getElementById("admin-sign-out");
      const roleSelect = document.getElementById("role-select");
      const roleSaveButton = document.getElementById("role-save");
      const roleCurrent = document.getElementById("role-current");
      const roleMessage = document.getElementById("role-message");
      const adminLogsSection = document.getElementById("admin-logs");
      const logTable = document.getElementById("log-table");
      const logsMessage = document.getElementById("logs-message");
      const logGroupSelect = document.getElementById("log-group-select");
      const resetSelectedLogsButton = document.getElementById("reset-selected-logs");
      const resetAllLogsButton = document.getElementById("reset-all-logs");
      const logCollapseButton = document.getElementById("log-collapse-btn");
      const logExpandButton = document.getElementById("log-expand-btn");

      let authMode = "signin";
      let currentUser = null;
      let currentGroupId = null;
      let currentProfile = { fullName: "" };
      let pendingIdentity = null;
      let rosterEntries = [];
      let rosterUnsubscribe = null;
      let groupUnsubscribe = null;
      let selfEntry = null;
      let isRosterMutating = false;
      let isRoleUpdating = false;
      let isPasswordVisible = false;
      let isAdmin = false;
      const adminRosterData = new Map();
      const adminRosterUnsubscribes = new Map();
      const minimizedAdminGroups = new Set();
      const ADMIN_LAYOUT_STORAGE_PREFIX = "adminGroupLayout";
      const LOG_LAYOUT_STORAGE_PREFIX = "logGroupLayout";
      const selectedLogGroups = new Set();
      let isResettingLogs = false;
      let logRefreshTimer = null;
      const LOG_REFRESH_INTERVAL_MS = 60_000;
      const RESET_CONFIRM_TIMEOUT_MS = 6_000;
      const resetConfirmTimers = new Map();
      let logsCollapsed = false;
      const collapsedLogGroups = new Set();

      function toggleViews(isSignedIn) {
        if (isSignedIn) {
          authCard.classList.add("hidden");
          dashboard.classList.toggle("hidden", Boolean(isAdmin));
        } else {
          authCard.classList.remove("hidden");
          dashboard.classList.add("hidden");
        }
      }

      function setAuthMessage(message, isError = false) {
        authMessage.textContent = message;
        authMessage.classList.toggle("error", isError);
      }

      function setRosterMessage(message = "", isError = false) {
        if (!rosterMessage) return;
        rosterMessage.textContent = message;
        rosterMessage.classList.toggle("error", isError);
      }

      function setGroupMessage(message = "", isError = false) {
        if (!groupMessage) return;
        groupMessage.textContent = message;
        groupMessage.classList.toggle("error", isError);
      }

      function setRoleMessage(message = "", isError = false) {
        if (!roleMessage) return;
        roleMessage.textContent = message;
        roleMessage.classList.toggle("error", isError);
      }

      function setLogMessage(message = "", isError = false) {
        if (!logsMessage) return;
        const text = message ?? "";
        logsMessage.textContent = text;
        logsMessage.classList.toggle("error", Boolean(text) && isError);
        logsMessage.classList.toggle("hidden", !text);
      }

      function syncLogCollapseButtons() {
        if (logCollapseButton) {
          logCollapseButton.disabled = logsCollapsed;
        }
        if (logExpandButton) {
          logExpandButton.disabled = !logsCollapsed;
        }
      }

      function setLogsCollapsed(collapsed) {
        logsCollapsed = Boolean(collapsed);
        if (logTable) {
          logTable.classList.toggle("hidden", logsCollapsed);
        }
        syncLogCollapseButtons();
      }

      function setLogGroupCollapsed(groupId, collapsed) {
        if (!isValidGroupId(groupId)) return;
        if (collapsed) {
          collapsedLogGroups.add(groupId);
        } else {
          collapsedLogGroups.delete(groupId);
        }
        saveLogLayout();
        renderStaffLogs();
      }

      function clearResetConfirmation(button) {
        if (!button) return;
        const timer = resetConfirmTimers.get(button);
        if (timer) {
          clearTimeout(timer);
          resetConfirmTimers.delete(button);
        }
        button.classList.remove("confirm");
        if (button.dataset.defaultLabel) {
          button.textContent = button.dataset.defaultLabel;
        }
        button.dataset.confirm = "false";
      }

      function requestResetConfirmation(button, confirmText) {
        if (!button) return false;
        const otherButton =
          button === resetAllLogsButton ? resetSelectedLogsButton : resetAllLogsButton;
        clearResetConfirmation(otherButton);
        if (button.dataset.confirm === "true") {
          clearResetConfirmation(button);
          return true;
        }
        button.dataset.confirm = "true";
        button.dataset.defaultLabel = button.dataset.defaultLabel || button.textContent;
        button.textContent = confirmText;
        button.classList.add("confirm");
        const timer = setTimeout(() => clearResetConfirmation(button), RESET_CONFIRM_TIMEOUT_MS);
        resetConfirmTimers.set(button, timer);
        return false;
      }

      function isAdminAccount(user) {
        const email = typeof user === "string" ? user : user?.email;
        return Boolean(email && ADMIN_EMAILS.has(String(email).toLowerCase()));
      }

      function setAdminMode(enabled) {
        isAdmin = Boolean(enabled);
        if (adminPanel) {
          adminPanel.classList.toggle("hidden", !isAdmin);
        }
        if (adminLogsSection) {
          adminLogsSection.classList.toggle("hidden", !isAdmin);
        }
        if (isAdmin && adminUserEmail && currentUser) {
          adminUserEmail.textContent = currentUser.email;
        }
        if (!isAdmin) {
          stopAdminRosterWatchers();
          stopLogTicker();
          if (adminGroupsContainer) {
            adminGroupsContainer.innerHTML = "";
          }
          if (logTable) {
            logTable.innerHTML = "";
          }
          selectedLogGroups.clear();
          collapsedLogGroups.clear();
          renderLogGroupSelector();
          setLogMessage("");
          setLogsCollapsed(false);
        } else {
          loadAdminLayout();
          loadLogLayout();
          renderAdminPanel();
          renderLogGroupSelector();
          renderStaffLogs();
          setLogMessage("");
          startLogTicker();
          setLogsCollapsed(false);
        }
      }

      function setPasswordVisibility(visible) {
        if (!passwordInput) return;
        isPasswordVisible = Boolean(visible);
        passwordInput.type = isPasswordVisible ? "text" : "password";
        if (passwordToggleButton) {
          passwordToggleButton.textContent = isPasswordVisible ? "Hide" : "Show";
          passwordToggleButton.setAttribute("aria-pressed", String(isPasswordVisible));
        }
      }

      function setAuthMode(mode) {
        authMode = mode === "register" ? "register" : "signin";
        const needsFullName = authMode === "register";
        modeButtons.forEach((button) => {
          const isActive = button.dataset.authMode === authMode;
          button.classList.toggle("active", isActive);
          button.setAttribute("aria-pressed", String(isActive));
        });
        fullNameField.classList.toggle("hidden", !needsFullName);
        fullNameInput.required = needsFullName;
        authSubmitButton.textContent = needsFullName ? "Create Account" : "Sign In";
        if (needsFullName) {
          attemptFullNamePrefill();
        }
        setAuthMessage("");
        setPasswordVisibility(false);
      }

      function isValidGroupId(groupId) {
        return Boolean(groupId && GROUPS[groupId]);
      }

      function adminLayoutStorageKey(user = currentUser) {
        const email = user?.email ? String(user.email).toLowerCase() : "default";
        return `${ADMIN_LAYOUT_STORAGE_PREFIX}:${email}`;
      }

      function saveAdminLayout(user = currentUser) {
        try {
          localStorage.setItem(adminLayoutStorageKey(user), JSON.stringify([...minimizedAdminGroups]));
        } catch {
          /* ignore storage issues */
        }
      }

      function loadAdminLayout(user = currentUser) {
        try {
          const stored = localStorage.getItem(adminLayoutStorageKey(user));
          if (!stored) return;
          const parsed = JSON.parse(stored);
          if (!Array.isArray(parsed)) return;
          minimizedAdminGroups.clear();
          parsed.forEach((groupId) => {
            if (isValidGroupId(groupId)) {
              minimizedAdminGroups.add(groupId);
            }
          });
        } catch {
          /* ignore storage issues */
        }
      }

      function logLayoutStorageKey(user = currentUser) {
        const email = user?.email ? String(user.email).toLowerCase() : "default";
        return `${LOG_LAYOUT_STORAGE_PREFIX}:${email}`;
      }

      function saveLogLayout(user = currentUser) {
        try {
          localStorage.setItem(logLayoutStorageKey(user), JSON.stringify([...collapsedLogGroups]));
        } catch {
          /* ignore storage issues */
        }
      }

      function loadLogLayout(user = currentUser) {
        try {
          const stored = localStorage.getItem(logLayoutStorageKey(user));
          if (!stored) return;
          const parsed = JSON.parse(stored);
          if (!Array.isArray(parsed)) return;
          collapsedLogGroups.clear();
          parsed.forEach((groupId) => {
            if (isValidGroupId(groupId)) {
              collapsedLogGroups.add(groupId);
            }
          });
        } catch {
          /* ignore storage issues */
        }
      }

      function roleLabel(roleId) {
        const match = ROLE_OPTIONS.find((role) => role.id === roleId);
        return match ? match.label : "";
      }

      function sanitizeRoleId(roleId) {
        return ROLE_OPTIONS.some((role) => role.id === roleId) ? roleId : "";
      }

      function populateRoleSelect() {
        if (!roleSelect) return;
        const current = roleSelect.value;
        roleSelect.innerHTML = '<option value="">Choose a role…</option>';
        ROLE_OPTIONS.forEach((role) => {
          const option = document.createElement("option");
          option.value = role.id;
          option.textContent = role.label;
          roleSelect.appendChild(option);
        });
        if (current && sanitizeRoleId(current)) {
          roleSelect.value = current;
        }
      }

      function setRoleControlsDisabled(disabled) {
        if (roleSelect) roleSelect.disabled = disabled;
        if (roleSaveButton) roleSaveButton.disabled = disabled;
      }

      function syncRoleUI(entry = selfEntry) {
        const roleId = sanitizeRoleId(entry?.role);
        if (roleSelect) {
          roleSelect.value = roleId;
        }
        if (roleCurrent) {
          const label = roleLabel(roleId);
          roleCurrent.textContent = label || "No role selected";
        }
        setRoleControlsDisabled(!currentUser || !currentGroupId || isRoleUpdating);
      }

      function groupLabel(groupId) {
        return GROUPS[groupId] ?? groupId ?? "Unknown";
      }

      function sanitizeFullName(value) {
        return value ? value.replace(/\s+/g, " ").trim() : "";
      }

      function rememberFullName(email, fullName) {
        if (!email || !fullName) return;
        try {
          localStorage.setItem(`fullName:${email}`, fullName);
        } catch {
          /* ignore storage issues */
        }
      }

      function recallFullName(email) {
        if (!email) return "";
        try {
          return localStorage.getItem(`fullName:${email}`) ?? "";
        } catch {
          return "";
        }
      }

      function getCurrentFullName() {
        return (
          sanitizeFullName(currentProfile?.fullName) ||
          sanitizeFullName(pendingIdentity?.fullName) ||
          ""
        );
      }

      async function saveProfileFullName(user, fullName) {
        if (!user || !fullName) return;
        const profileRef = doc(db, "userProfiles", user.uid);
        try {
          await setDoc(
            profileRef,
            {
              fullName,
              email: user.email,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          currentProfile = { fullName };
        } catch (error) {
          console.error("Unable to save profile name", error);
          throw error;
        }
      }

      async function fetchProfile(user) {
        if (!user) return null;
        try {
          const snapshot = await getDoc(doc(db, "userProfiles", user.uid));
          if (snapshot.exists()) {
            return snapshot.data();
          }
        } catch (error) {
          console.error("Unable to load profile", error);
        }
        return null;
      }

      function toDate(value) {
        if (!value) return null;
        if (typeof value.toDate === "function") {
          try {
            return value.toDate();
          } catch {
            return null;
          }
        }
        const date = new Date(value);
        return Number.isNaN(date.getTime()) ? null : date;
      }

      function getTimestampValue(value) {
        const date = toDate(value);
        return date ? date.getTime() : Number.MAX_SAFE_INTEGER;
      }

      function formatTime(value) {
        const date = toDate(value);
        if (!date) return "--:--";
        try {
          return new Intl.DateTimeFormat("en-US", {
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          }).format(date);
        } catch {
          return "--:--";
        }
      }

      function formatDuration(ms) {
        const safeMs = Number.isFinite(ms) ? ms : 0;
        if (safeMs <= 0) return "0m";
        const totalMinutes = Math.round(safeMs / 60000);
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        if (hours && minutes) return `${hours}h ${minutes}m`;
        if (hours) return `${hours}h`;
        return `${minutes}m`;
      }

      function formatRelativeTime(value) {
        const date = toDate(value);
        if (!date) return "—";
        const diffMs = Date.now() - date.getTime();
        const direction = diffMs >= 0 ? "ago" : "from now";
        const absMs = Math.abs(diffMs);
        const minute = 60_000;
        const hour = 3_600_000;
        const day = 86_400_000;
        if (absMs < minute) return "<1m ago";
        if (absMs < hour) return `${Math.round(absMs / minute)}m ${direction}`;
        if (absMs < day) return `${Math.round(absMs / hour)}h ${direction}`;
        return `${Math.round(absMs / day)}d ${direction}`;
      }

      function normalizeBreakStats(entry) {
        const breakCount = Number.isFinite(entry?.breakCount) ? entry.breakCount : 0;
        const breakDurationMs = Number.isFinite(entry?.breakDurationMs)
          ? Math.max(0, entry.breakDurationMs)
          : 0;
        const mealBreakDurationMs = Number.isFinite(entry?.mealBreakDurationMs)
          ? Math.max(0, entry.mealBreakDurationMs)
          : 0;
        const logDateKey = typeof entry?.logDateKey === "string" ? entry.logDateKey : "";
        return { breakCount, breakDurationMs, mealBreakDurationMs, logDateKey };
      }

      function getBreakStatsForToday(entry) {
        const today = currentResetDateKey();
        const { breakCount, breakDurationMs, mealBreakDurationMs, logDateKey } =
          normalizeBreakStats(entry);
        if (logDateKey !== today) {
          return {
            breakCount: 0,
            breakDurationMs: 0,
            mealBreakDurationMs: 0,
            logDateKey: today,
            reset: true,
          };
        }
        return {
          breakCount,
          breakDurationMs,
          mealBreakDurationMs,
          logDateKey: today,
          reset: false,
        };
      }

      function elapsedSince(value) {
        const date = toDate(value);
        if (!date) return 0;
        return Math.max(0, Date.now() - date.getTime());
      }

      function currentMealBreakElapsed(entry) {
        if (!isOnMealBreakToday(entry)) return 0;
        return elapsedSince(entry.mealJoinedAt);
      }

      function currentBreakElapsed(entry) {
        if (!entry?.isOnBreak || !isOnBreakToday(entry)) return 0;
        return elapsedSince(entry.joinedAt);
      }

      function currentResetDateKey() {
        try {
          const formatter = new Intl.DateTimeFormat("en-CA", {
            timeZone: RESET_TIMEZONE,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
          });
          return formatter.format(new Date());
        } catch {
          const today = new Date();
          const month = String(today.getMonth() + 1).padStart(2, "0");
          const day = String(today.getDate()).padStart(2, "0");
          return `${today.getFullYear()}-${month}-${day}`;
        }
      }

      function dateKeyFor(value) {
        const date = toDate(value);
        if (!date) return "";
        try {
          const formatter = new Intl.DateTimeFormat("en-CA", {
            timeZone: RESET_TIMEZONE,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
          });
          return formatter.format(date);
        } catch {
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          return `${date.getFullYear()}-${month}-${day}`;
        }
      }

      function isOnBreakToday(entry) {
        const onBreak = entry?.isOnBreak;
        if (!entry || !onBreak || !entry.joinedAt) return false;
        return dateKeyFor(entry.joinedAt) === currentResetDateKey();
      }

      function isOnMealBreakToday(entry) {
        const onMealBreak = entry?.isOnMealBreak;
        if (!entry || !onMealBreak || !entry.mealJoinedAt) return false;
        return dateKeyFor(entry.mealJoinedAt) === currentResetDateKey();
      }

      function updateActionButtons() {
        if (!currentUser || !currentGroupId) {
          if (joinButton) joinButton.disabled = true;
          if (leaveButton) leaveButton.disabled = true;
          if (mealJoinButton) mealJoinButton.disabled = true;
          if (mealLeaveButton) mealLeaveButton.disabled = true;
          return;
        }
        const entry =
          rosterEntries.find((record) => record.id === currentUser.uid) ?? selfEntry;
        const hasRole = Boolean(sanitizeRoleId(entry?.role));
        const isOnBreak = isOnBreakToday(entry);
        const isOnMealBreak = isOnMealBreakToday(entry);
        const disableBreakJoin = isRosterMutating || isOnBreak || isOnMealBreak || !hasRole;
        const disableMealJoin = isRosterMutating || isOnMealBreak || isOnBreak || !hasRole;
        if (joinButton) joinButton.disabled = disableBreakJoin;
        if (leaveButton) leaveButton.disabled = isRosterMutating || !isOnBreak;
        if (mealJoinButton) mealJoinButton.disabled = disableMealJoin;
        if (mealLeaveButton) mealLeaveButton.disabled = isRosterMutating || !isOnMealBreak;
      }

      function createListItem(entry, { showJoinedAt = false, joinedAtKey = "joinedAt" } = {}) {
        const li = document.createElement("li");

        const person = document.createElement("span");
        person.className = "person";

        const nameSpan = document.createElement("span");
        nameSpan.className = "person-name";
        nameSpan.textContent = entry.fullName ?? entry.email ?? "Unknown worker";
        person.appendChild(nameSpan);

        const roleText = roleLabel(entry.role);
        const roleSpan = document.createElement("span");
        roleSpan.className = "person-role";
        roleSpan.textContent = roleText || "Role not set";
        person.appendChild(roleSpan);

        li.appendChild(person);

        const joinedValue = joinedAtKey ? entry?.[joinedAtKey] : null;
        if (showJoinedAt && joinedValue) {
          const timeSpan = document.createElement("span");
          timeSpan.className = "time-badge";
          timeSpan.textContent = formatTime(joinedValue);
          li.appendChild(timeSpan);
        }

        return li;
      }

      function populateList(target, entries, emptyText, options = {}) {
        if (!entries.length) {
          target.innerHTML = `<li class="empty">${emptyText}</li>`;
          return;
        }
        const fragment = document.createDocumentFragment();
        entries.forEach((entry) => {
          fragment.appendChild(createListItem(entry, options));
        });
        target.replaceChildren(fragment);
      }

      function normalizeRosterDocument(docSnap) {
        const data = docSnap.data();
        const stats = getBreakStatsForToday(data);
        return {
          id: docSnap.id,
          ...data,
          role: sanitizeRoleId(data.role),
          breakCount: stats.breakCount,
          breakDurationMs: stats.breakDurationMs,
          mealBreakDurationMs: stats.mealBreakDurationMs,
          lastBreakAt: data.lastBreakAt ?? null,
          logDateKey: stats.logDateKey,
        };
      }

      function renderLists() {
        if (!currentUser) {
          onBreakList.innerHTML = '<li class="empty">Sign in to see the break list.</li>';
          offBreakList.innerHTML = '<li class="empty">Sign in to see the break list.</li>';
          onMealBreakList.innerHTML = '<li class="empty">Sign in to see the meal break list.</li>';
          offMealBreakList.innerHTML = '<li class="empty">Sign in to see the meal break list.</li>';
          updateActionButtons();
          syncRoleUI();
          return;
        }

        if (!currentGroupId) {
          const awaiting = "Waiting for a group assignment.";
          onBreakList.innerHTML = `<li class="empty">${awaiting}</li>`;
          offBreakList.innerHTML = `<li class="empty">${awaiting}</li>`;
          onMealBreakList.innerHTML = `<li class="empty">${awaiting}</li>`;
          offMealBreakList.innerHTML = `<li class="empty">${awaiting}</li>`;
          updateActionButtons();
          syncRoleUI();
          return;
        }

        const onBreakEntries = rosterEntries.filter((entry) => isOnBreakToday(entry));
        const workingEntries = rosterEntries.filter((entry) => !isOnBreakToday(entry));
        const onMealBreakEntries = rosterEntries.filter((entry) => isOnMealBreakToday(entry));
        const offMealBreakEntries = rosterEntries.filter((entry) => !isOnMealBreakToday(entry));

        const onBreakSorted = [...onBreakEntries].sort(
          (a, b) => getTimestampValue(a.joinedAt) - getTimestampValue(b.joinedAt)
        );
        const workingSorted = [...workingEntries].sort((a, b) =>
          (a.email ?? "").localeCompare(b.email ?? "", undefined, { sensitivity: "base" })
        );
        const onMealBreakSorted = [...onMealBreakEntries].sort(
          (a, b) => getTimestampValue(a.mealJoinedAt) - getTimestampValue(b.mealJoinedAt)
        );
        const offMealBreakSorted = [...offMealBreakEntries].sort((a, b) =>
          (a.email ?? "").localeCompare(b.email ?? "", undefined, { sensitivity: "base" })
        );
        const hasRosterEntries = rosterEntries.length > 0;
        const onBreakEmptyText = hasRosterEntries
          ? "Nobody is on break right now."
          : "No one is assigned to this group yet.";
        const workingEmptyText = hasRosterEntries
          ? "Nobody is working right now."
          : "No one is assigned to this group yet.";
        const onMealEmptyText = hasRosterEntries
          ? "Nobody is on meal break right now."
          : "No one is assigned to this group yet.";
        const offMealEmptyText = hasRosterEntries
          ? "Everyone is on meal break."
          : "No one is assigned to this group yet.";

        populateList(onBreakList, onBreakSorted, onBreakEmptyText, {
          showJoinedAt: true,
        });
        populateList(offBreakList, workingSorted, workingEmptyText);
        populateList(onMealBreakList, onMealBreakSorted, onMealEmptyText, {
          showJoinedAt: true,
          joinedAtKey: "mealJoinedAt",
        });
        populateList(offMealBreakList, offMealBreakSorted, offMealEmptyText);
        updateActionButtons();
        syncRoleUI();
      }

      function renderAdminPanel() {
        if (!adminGroupsContainer) return;
        if (!isAdmin) {
          adminGroupsContainer.innerHTML = "";
          return;
        }

        const groupIds = Object.keys(GROUPS);
        if (!groupIds.length) {
          adminGroupsContainer.innerHTML = '<p class="muted">No groups configured.</p>';
          return;
        }

        if (minimizedAdminGroups.size >= groupIds.length) {
          minimizedAdminGroups.delete(groupIds[0]);
        }

        const expandedGroupIds = groupIds.filter((id) => !minimizedAdminGroups.has(id));
        const minimizedGroupIds = groupIds.filter((id) => minimizedAdminGroups.has(id));
        const orderedGroupIds = [...expandedGroupIds, ...minimizedGroupIds];
        const fragment = document.createDocumentFragment();

        orderedGroupIds.forEach((groupId) => {
          const roster = adminRosterData.get(groupId) ?? [];
          const onEntries = roster.filter((entry) => isOnBreakToday(entry));
          const offEntries = roster.filter((entry) => !isOnBreakToday(entry));
          const onMealEntries = roster.filter((entry) => isOnMealBreakToday(entry));
          const offMealEntries = roster.filter((entry) => !isOnMealBreakToday(entry));
          const hasRosterEntries = roster.length > 0;
          const onBreakEmptyText = hasRosterEntries
            ? "Nobody is on break right now."
            : "No users in this group yet.";
          const workingEmptyText = hasRosterEntries
            ? "Nobody is working right now."
            : "No users in this group yet.";
          const onMealEmptyText = hasRosterEntries
            ? "Nobody is on meal break right now."
            : "No users in this group yet.";
          const offMealEmptyText = hasRosterEntries
            ? "Everyone is on meal break."
            : "No users in this group yet.";
          const isMinimized = minimizedAdminGroups.has(groupId);

          const card = document.createElement("div");
          card.className = `admin-group-card${isMinimized ? " minimized" : ""}`;

          const header = document.createElement("div");
          header.className = "admin-group-header";

          const title = document.createElement("h3");
          title.textContent = `Group ${groupLabel(groupId)}`;
          header.appendChild(title);

          const toggleButton = document.createElement("button");
          toggleButton.type = "button";
          toggleButton.className = "ghost admin-toggle";
          toggleButton.textContent = isMinimized ? "Expand" : "Collapse";
          toggleButton.setAttribute("aria-pressed", String(isMinimized));
          toggleButton.setAttribute("aria-expanded", String(!isMinimized));
          const expandedCount = groupIds.length - minimizedAdminGroups.size;
          toggleButton.disabled = !isMinimized && expandedCount <= 1;
          toggleButton.addEventListener("click", () => {
            const currentlyMinimized = minimizedAdminGroups.has(groupId);
            const expandedNow = groupIds.length - minimizedAdminGroups.size;
            if (!currentlyMinimized && expandedNow <= 1) {
              return;
            }
            if (currentlyMinimized) {
              minimizedAdminGroups.delete(groupId);
            } else {
              minimizedAdminGroups.add(groupId);
            }
            renderAdminPanel();
          });
          header.appendChild(toggleButton);
          card.appendChild(header);

          const body = document.createElement("div");
          body.className = "admin-group-body";

          const onLabel = document.createElement("p");
          onLabel.className = "eyebrow";
          onLabel.textContent = "On break";
          body.appendChild(onLabel);

          const onList = document.createElement("ul");
          onList.className = "status-list";
          const onSorted = [...onEntries].sort(
            (a, b) => getTimestampValue(a.joinedAt) - getTimestampValue(b.joinedAt)
          );
          populateList(onList, onSorted, onBreakEmptyText, { showJoinedAt: true });
          body.appendChild(onList);

          const divider = document.createElement("div");
          divider.className = "admin-group-divider";
          body.appendChild(divider);

          const offLabel = document.createElement("p");
          offLabel.className = "eyebrow";
          offLabel.textContent = "Working";
          body.appendChild(offLabel);

          const offList = document.createElement("ul");
          offList.className = "status-list";
          const offSorted = [...offEntries].sort((a, b) =>
            (a.email ?? "").localeCompare(b.email ?? "", undefined, { sensitivity: "base" })
          );
          populateList(offList, offSorted, workingEmptyText);
          body.appendChild(offList);

          const dividerMeal = document.createElement("div");
          dividerMeal.className = "admin-group-divider";
          body.appendChild(dividerMeal);

          const onMealLabel = document.createElement("p");
          onMealLabel.className = "eyebrow";
          onMealLabel.textContent = "On meal break";
          body.appendChild(onMealLabel);

          const onMealList = document.createElement("ul");
          onMealList.className = "status-list";
          const onMealSorted = [...onMealEntries].sort(
            (a, b) => getTimestampValue(a.mealJoinedAt) - getTimestampValue(b.mealJoinedAt)
          );
          populateList(onMealList, onMealSorted, onMealEmptyText, {
            showJoinedAt: true,
            joinedAtKey: "mealJoinedAt",
          });
          body.appendChild(onMealList);

          const dividerMealOff = document.createElement("div");
          dividerMealOff.className = "admin-group-divider";
          body.appendChild(dividerMealOff);

          const offMealLabel = document.createElement("p");
          offMealLabel.className = "eyebrow";
          offMealLabel.textContent = "Not on meal break";
          body.appendChild(offMealLabel);

          const offMealList = document.createElement("ul");
          offMealList.className = "status-list";
          const offMealSorted = [...offMealEntries].sort((a, b) =>
            (a.email ?? "").localeCompare(b.email ?? "", undefined, { sensitivity: "base" })
          );
          populateList(offMealList, offMealSorted, offMealEmptyText);
          body.appendChild(offMealList);

          card.appendChild(body);
          fragment.appendChild(card);
        });

        adminGroupsContainer.replaceChildren(fragment);
        saveAdminLayout();
        renderStaffLogs();
      }

      function syncLogResetButtons() {
        if (resetSelectedLogsButton) {
          const disabled = !isAdmin || isResettingLogs || selectedLogGroups.size === 0;
          resetSelectedLogsButton.disabled = disabled;
          if (disabled) {
            clearResetConfirmation(resetSelectedLogsButton);
          }
        }
        if (resetAllLogsButton) {
          const disabled = !isAdmin || isResettingLogs;
          resetAllLogsButton.disabled = disabled;
          if (disabled) {
            clearResetConfirmation(resetAllLogsButton);
          }
        }
      }

      function renderLogGroupSelector() {
        if (!logGroupSelect) return;
        const groupIds = Object.keys(GROUPS);
        if (!groupIds.length) {
          logGroupSelect.innerHTML = '<p class="muted">No groups configured.</p>';
          syncLogResetButtons();
          return;
        }
        [...selectedLogGroups].forEach((groupId) => {
          if (!isValidGroupId(groupId)) {
            selectedLogGroups.delete(groupId);
          }
        });
        const fragment = document.createDocumentFragment();
        groupIds.forEach((groupId) => {
          const labelEl = document.createElement("label");
          labelEl.className = "log-option";

          const input = document.createElement("input");
          input.type = "checkbox";
          input.value = groupId;
          input.checked = selectedLogGroups.has(groupId);
          input.addEventListener("change", () => {
            if (input.checked) {
              selectedLogGroups.add(groupId);
            } else {
              selectedLogGroups.delete(groupId);
            }
            syncLogResetButtons();
          });
          labelEl.appendChild(input);

          const text = document.createElement("span");
          text.textContent = `Group ${groupLabel(groupId)}`;
          labelEl.appendChild(text);
          fragment.appendChild(labelEl);
        });
        logGroupSelect.replaceChildren(fragment);
        syncLogResetButtons();
      }

      function renderStaffLogs() {
        if (!logTable) return;
        if (!isAdmin) {
          logTable.innerHTML = "";
          return;
        }
        const groupIds = Object.keys(GROUPS);
        if (!groupIds.length) {
          logTable.innerHTML = '<p class="muted">No groups configured.</p>';
          return;
        }
        [...collapsedLogGroups].forEach((groupId) => {
          if (!isValidGroupId(groupId)) {
            collapsedLogGroups.delete(groupId);
          }
        });
        if (collapsedLogGroups.size >= groupIds.length) {
          collapsedLogGroups.delete(groupIds[0]);
        }
        saveLogLayout();
        const expandedGroupIds = groupIds.filter((id) => !collapsedLogGroups.has(id));
        const minimizedGroupIds = groupIds.filter((id) => collapsedLogGroups.has(id));
        const orderedGroupIds = [...expandedGroupIds, ...minimizedGroupIds];

        const fragment = document.createDocumentFragment();
        orderedGroupIds.forEach((groupId) => {
          const roster = adminRosterData.get(groupId) ?? [];
          const isCollapsed = collapsedLogGroups.has(groupId);
          const card = document.createElement("div");
          card.className = `log-card${isCollapsed ? " minimized" : ""}`;

          const header = document.createElement("div");
          header.className = "log-card-header";

          const title = document.createElement("h3");
          title.textContent = `Group ${groupLabel(groupId)}`;
          header.appendChild(title);

          const toggle = document.createElement("button");
          toggle.type = "button";
          toggle.className = "ghost admin-toggle";
          toggle.textContent = isCollapsed ? "Expand" : "Collapse";
          const expandedCount = groupIds.length - collapsedLogGroups.size;
          toggle.disabled = !isCollapsed && expandedCount <= 1;
          toggle.setAttribute("aria-pressed", String(isCollapsed));
          toggle.setAttribute("aria-expanded", String(!isCollapsed));
          toggle.addEventListener("click", () => {
            const currentlyCollapsed = collapsedLogGroups.has(groupId);
            const expandedNow = groupIds.length - collapsedLogGroups.size;
            if (!currentlyCollapsed && expandedNow <= 1) {
              return;
            }
            setLogGroupCollapsed(groupId, !currentlyCollapsed);
          });
          header.appendChild(toggle);
          card.appendChild(header);

          const body = document.createElement("div");
          body.className = "log-card-body";

          if (!roster.length) {
            const empty = document.createElement("p");
            empty.className = "log-empty";
            empty.textContent = "No users in this group yet.";
            body.appendChild(empty);
            card.appendChild(body);
            fragment.appendChild(card);
            return;
          }

          const table = document.createElement("table");
          const thead = document.createElement("thead");
          thead.innerHTML =
            "<tr><th>Worker</th><th>Role</th><th>Breaks</th><th>Time on break</th><th>Time on meal break</th><th>Last break</th></tr>";
          table.appendChild(thead);

          const tbody = document.createElement("tbody");
          const sortedRoster = [...roster].sort((a, b) => {
            const statsA = getBreakStatsForToday(a);
            const statsB = getBreakStatsForToday(b);
            const totalA = statsA.breakDurationMs + currentBreakElapsed(a);
            const totalB = statsB.breakDurationMs + currentBreakElapsed(b);
            if (totalA !== totalB) return totalB - totalA;
            return (a.fullName ?? a.email ?? "").localeCompare(
              b.fullName ?? b.email ?? "",
              undefined,
              { sensitivity: "base" }
            );
          });
          sortedRoster.forEach((entry) => {
            const stats = getBreakStatsForToday(entry);
            const totalMs = stats.breakDurationMs + currentBreakElapsed(entry);
            const mealTotalMs = stats.mealBreakDurationMs + currentMealBreakElapsed(entry);
            const lastBreak = entry.lastBreakAt ?? null;
            const row = document.createElement("tr");
            const workerCell = document.createElement("td");
            workerCell.textContent = entry.fullName ?? entry.email ?? "Unknown worker";
            workerCell.dataset.label = "Worker";
            row.appendChild(workerCell);

            const roleCell = document.createElement("td");
            roleCell.textContent = roleLabel(entry.role) || "No role set";
            roleCell.dataset.label = "Role";
            row.appendChild(roleCell);

            const countCell = document.createElement("td");
            countCell.textContent = String(stats.breakCount ?? 0);
            countCell.dataset.label = "Breaks";
            row.appendChild(countCell);

            const timeCell = document.createElement("td");
            timeCell.textContent = formatDuration(totalMs);
            timeCell.dataset.label = "Time on break";
            row.appendChild(timeCell);

            const mealTimeCell = document.createElement("td");
            mealTimeCell.textContent = formatDuration(mealTotalMs);
            mealTimeCell.dataset.label = "Time on meal break";
            row.appendChild(mealTimeCell);

            const lastBreakCell = document.createElement("td");
            lastBreakCell.textContent = formatRelativeTime(lastBreak);
            lastBreakCell.dataset.label = "Last break";
            row.appendChild(lastBreakCell);

            tbody.appendChild(row);
          });
          table.appendChild(tbody);
          body.appendChild(table);
          card.appendChild(body);
          fragment.appendChild(card);
        });

        logTable.replaceChildren(fragment);
        logTable.classList.toggle("hidden", logsCollapsed);
        syncLogCollapseButtons();
      }

      function startLogTicker() {
        stopLogTicker();
        if (!isAdmin) return;
        logRefreshTimer = setInterval(() => {
          renderStaffLogs();
        }, LOG_REFRESH_INTERVAL_MS);
      }

      function stopLogTicker() {
        if (logRefreshTimer) {
          clearInterval(logRefreshTimer);
          logRefreshTimer = null;
        }
      }

      async function resetLogsForGroups(groupIds) {
        if (!groupIds.length || !isAdmin) return;
        isResettingLogs = true;
        syncLogResetButtons();
        const label =
          groupIds.length === Object.keys(GROUPS).length
            ? "all groups"
            : `group${groupIds.length > 1 ? "s" : ""} ${groupIds
                .map((groupId) => groupLabel(groupId))
                .join(", ")}`;
        setLogMessage(`Resetting logs for ${label}…`);
        try {
          for (const groupId of groupIds) {
            const rosterRef = collection(db, "groups", groupId, "busRoster");
            const snapshot = await getDocs(rosterRef);
            if (snapshot.empty) continue;
            const docs = snapshot.docs;
            for (let i = 0; i < docs.length; i += 400) {
              const batch = writeBatch(db);
              docs.slice(i, i + 400).forEach((docSnap) => {
                batch.set(
                  docSnap.ref,
                  {
                    isOnBreak: false,
                    joinedAt: null,
                    isOnMealBreak: false,
                    mealJoinedAt: null,
                    breakCount: 0,
                    breakDurationMs: 0,
                    mealBreakDurationMs: 0,
                    lastBreakAt: null,
                    logDateKey: currentResetDateKey(),
                    updatedAt: serverTimestamp(),
                  },
                  { merge: true }
                );
              });
              await batch.commit();
            }
          }
          setLogMessage(`Logs reset for ${label}.`);
        } catch (error) {
          console.error("Log reset failed", error);
          setLogMessage("Unable to reset logs. Try again.", true);
        } finally {
          isResettingLogs = false;
          clearResetConfirmation(resetAllLogsButton);
          clearResetConfirmation(resetSelectedLogsButton);
          syncLogResetButtons();
        }
      }

      function startAdminRosterWatchers() {
        if (!isAdmin) return;
        stopAdminRosterWatchers();
        Object.keys(GROUPS).forEach((groupId) => {
          const rosterRef = collection(db, "groups", groupId, "busRoster");
          const unsubscribe = onSnapshot(
            rosterRef,
            (snapshot) => {
              const roster = snapshot.docs.map((docSnap) => normalizeRosterDocument(docSnap));
              adminRosterData.set(groupId, roster);
              renderAdminPanel();
            },
            (error) => {
              console.error(`Admin roster listener failed for group ${groupId}`, error);
            }
          );
          adminRosterUnsubscribes.set(groupId, unsubscribe);
        });
        renderAdminPanel();
      }

      function stopAdminRosterWatchers() {
        adminRosterUnsubscribes.forEach((unsubscribe) => {
          try {
            unsubscribe();
          } catch {
            /* ignore */
          }
        });
        adminRosterUnsubscribes.clear();
        adminRosterData.clear();
        renderAdminPanel();
      }

      async function ensureRosterEntry(user, groupId) {
        if (!user || !groupId) return;
        const ref = doc(db, "groups", groupId, "busRoster", user.uid);
        const fullName = getCurrentFullName() || user.email;
        try {
          const snapshot = await getDoc(ref);
          if (!snapshot.exists()) {
            const seed = {
              email: user.email,
              fullName,
              role: null,
              isOnBreak: false,
              isOnMealBreak: false,
              joinedAt: null,
              mealJoinedAt: null,
              lastBreakAt: null,
              breakCount: 0,
              breakDurationMs: 0,
              mealBreakDurationMs: 0,
              logDateKey: currentResetDateKey(),
              updatedAt: serverTimestamp(),
            };
            await setDoc(ref, seed);
            selfEntry = { id: user.uid, ...seed };
          } else {
            const data = snapshot.data();
            const roleId = sanitizeRoleId(data.role);
            const stats = getBreakStatsForToday(data);
            selfEntry = {
              id: user.uid,
              ...data,
              role: roleId,
              breakCount: stats.breakCount,
              breakDurationMs: stats.breakDurationMs,
              mealBreakDurationMs: stats.mealBreakDurationMs,
              lastBreakAt: data.lastBreakAt ?? null,
              logDateKey: stats.logDateKey,
            };
            if (stats.reset) {
              await setDoc(
                ref,
                {
                  breakCount: 0,
                  breakDurationMs: 0,
                  mealBreakDurationMs: 0,
                  lastBreakAt: data.lastBreakAt ?? null,
                  logDateKey: stats.logDateKey,
                  updatedAt: serverTimestamp(),
                },
                { merge: true }
              );
            }
            if (fullName && data.fullName !== fullName) {
              await setDoc(
                ref,
                {
                  fullName,
                  email: user.email,
                  updatedAt: serverTimestamp(),
                },
                { merge: true }
              );
              selfEntry.fullName = fullName;
            }
            if (data.role !== roleId) {
              await setDoc(
                ref,
                {
                  role: roleId || null,
                  updatedAt: serverTimestamp(),
                },
                { merge: true }
              );
            }
          }
          updateActionButtons();
          syncRoleUI(selfEntry);
        } catch (error) {
          console.error("Unable to prepare roster entry", error);
          setRosterMessage("Unable to prepare your roster slot.", true);
        }
      }

      function startRosterSubscription(groupId) {
        if (!groupId) return;
        stopRosterSubscription();
        const rosterRef = collection(db, "groups", groupId, "busRoster");
        rosterUnsubscribe = onSnapshot(
          rosterRef,
          (snapshot) => {
            rosterEntries = snapshot.docs.map((docSnap) => normalizeRosterDocument(docSnap));
            if (currentUser) {
              const latestSelf = rosterEntries.find((entry) => entry.id === currentUser.uid);
              if (latestSelf) {
                selfEntry = latestSelf;
              }
            }
            syncRoleUI(selfEntry);
            renderLists();
          },
          (error) => {
            console.error("Roster listener error", error);
            setRosterMessage("Live roster updates paused. Refresh the page.", true);
          }
        );
      }

      function stopRosterSubscription() {
        if (rosterUnsubscribe) {
          rosterUnsubscribe();
          rosterUnsubscribe = null;
        }
        rosterEntries = [];
        selfEntry = null;
        renderLists();
      }

      function startGroupWatcher(user) {
        stopGroupWatcher();
        if (!user) return;
        const groupRef = doc(db, "userGroups", user.uid);
        groupUnsubscribe = onSnapshot(
          groupRef,
          (snapshot) => {
            handleGroupSnapshot(snapshot).catch((error) => {
              console.error("Group handling failed", error);
              setGroupMessage("Unable to load your group.", true);
            });
          },
          (error) => {
            console.error("Group listener error", error);
            currentGroupId = null;
            setGroupMessage("Unable to load your group.", true);
            stopRosterSubscription();
            updateActionButtons();
          }
        );
      }

      function stopGroupWatcher() {
        if (groupUnsubscribe) {
          groupUnsubscribe();
          groupUnsubscribe = null;
        }
      }

      async function handleGroupSnapshot(snapshot) {
        if (!currentUser) return;
        if (!snapshot.exists()) {
          currentGroupId = null;
          setGroupMessage("No group assigned. Contact the owner.", true);
          stopRosterSubscription();
          updateActionButtons();
          setRoleControlsDisabled(true);
          setRoleMessage("Role selection will be available after you get a group.", true);
          syncRoleUI();
          return;
        }
        const data = snapshot.data();
        const groupId = data.groupId;
        if (!isValidGroupId(groupId)) {
          currentGroupId = null;
          setGroupMessage("Invalid group assignment. Contact the owner.", true);
          stopRosterSubscription();
          updateActionButtons();
          setRoleControlsDisabled(true);
          setRoleMessage("Role selection will be available after you get a valid group.", true);
          syncRoleUI();
          return;
        }
        if (groupId === currentGroupId) {
          setGroupMessage(`Group: ${groupLabel(groupId)}`);
          return;
        }
        currentGroupId = groupId;
        setGroupMessage(`Group: ${groupLabel(groupId)}`);
        setRosterMessage("");
        setRoleMessage("");
        setRoleControlsDisabled(false);
        stopRosterSubscription();
        await ensureRosterEntry(currentUser, groupId);
        startRosterSubscription(groupId);
      }

      async function updateBreakStatus(targetState) {
        if (!currentUser || !currentGroupId || isRosterMutating) {
          if (!currentGroupId) {
            setRosterMessage("You need a group before updating break status.", true);
          }
          return;
        }
        const currentEntry =
          rosterEntries.find((entry) => entry.id === currentUser.uid) ?? selfEntry ?? {};
        if (!sanitizeRoleId(currentEntry.role)) {
          setRoleMessage("Select your role before updating your break.", true);
          return;
        }
        if (targetState && isOnMealBreakToday(currentEntry)) {
          setRosterMessage("End your meal break first.", true);
          return;
        }
        const stats = getBreakStatsForToday(currentEntry);
        let breakCount = stats.breakCount;
        let breakDurationMs = stats.breakDurationMs;
        const mealBreakDurationMs = stats.mealBreakDurationMs;
        const startingBreak = Boolean(targetState);
        const currentlyOnBreak = isOnBreakToday(currentEntry);
        const lastBreakAt = !startingBreak && currentlyOnBreak ? new Date() : currentEntry.lastBreakAt ?? null;
        isRosterMutating = true;
        updateActionButtons();
        setRosterMessage(startingBreak ? "Starting your break…" : "Ending your break…");

        const fullName = getCurrentFullName() || currentUser.email;
        if (startingBreak) {
          if (!currentlyOnBreak) {
            breakCount += 1;
          }
        } else if (currentlyOnBreak) {
          const joinedAtDate = toDate(currentEntry.joinedAt);
          const elapsed = joinedAtDate ? Math.max(0, Date.now() - joinedAtDate.getTime()) : 0;
          breakDurationMs += elapsed;
        }
        const optimisticEntry = {
          id: currentUser.uid,
          email: currentUser.email,
          fullName,
          role: sanitizeRoleId(currentEntry.role) || null,
          isOnBreak: startingBreak,
          joinedAt: startingBreak ? new Date() : null,
          isOnMealBreak: currentEntry.isOnMealBreak ?? false,
          mealJoinedAt: currentEntry.mealJoinedAt ?? null,
          breakCount,
          breakDurationMs,
          lastBreakAt,
          mealBreakDurationMs,
          logDateKey: stats.logDateKey,
        };
        const index = rosterEntries.findIndex((entry) => entry.id === currentUser.uid);
        if (index >= 0) {
          rosterEntries[index] = { ...rosterEntries[index], ...optimisticEntry };
        } else {
          rosterEntries = [...rosterEntries, optimisticEntry];
        }
        selfEntry = optimisticEntry;
        renderLists();

        try {
          await setDoc(
            doc(db, "groups", currentGroupId, "busRoster", currentUser.uid),
            {
              email: currentUser.email,
              fullName,
              role: sanitizeRoleId(optimisticEntry.role) || null,
              isOnBreak: targetState,
              joinedAt: targetState ? serverTimestamp() : null,
              isOnMealBreak: optimisticEntry.isOnMealBreak ?? false,
              mealJoinedAt: optimisticEntry.mealJoinedAt ?? null,
              breakCount,
              breakDurationMs,
              lastBreakAt,
              mealBreakDurationMs,
              logDateKey: stats.logDateKey,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          setRosterMessage(targetState ? "You are on break." : "You are back from break.");
        } catch (error) {
          console.error("Roster update failed", error);
          setRosterMessage("Update failed. Please try again.", true);
        } finally {
          isRosterMutating = false;
          updateActionButtons();
        }
      }

      async function updateMealBreakStatus(targetState) {
        if (!currentUser || !currentGroupId || isRosterMutating) {
          if (!currentGroupId) {
            setRosterMessage("You need a group before updating meal break status.", true);
          }
          return;
        }
        const currentEntry =
          rosterEntries.find((entry) => entry.id === currentUser.uid) ?? selfEntry ?? {};
        if (!sanitizeRoleId(currentEntry.role)) {
          setRoleMessage("Select your role before updating your break.", true);
          return;
        }
        if (targetState && isOnBreakToday(currentEntry)) {
          setRosterMessage("End your regular break first.", true);
          return;
        }
        const stats = getBreakStatsForToday(currentEntry);
        let breakCount = stats.breakCount;
        let breakDurationMs = stats.breakDurationMs;
        let mealBreakDurationMs = stats.mealBreakDurationMs;
        const currentlyOnMealBreak = isOnMealBreakToday(currentEntry);
        const startingMealBreak = Boolean(targetState);
        const lastBreakAt =
          !startingMealBreak && currentlyOnMealBreak
            ? new Date()
            : currentEntry.lastBreakAt ?? null;
        isRosterMutating = true;
        updateActionButtons();
        setRosterMessage(targetState ? "Starting your meal break…" : "Ending your meal break…");

        if (startingMealBreak) {
          if (!currentlyOnMealBreak) {
            breakCount += 1;
          }
        } else if (currentlyOnMealBreak) {
          const elapsed = elapsedSince(currentEntry.mealJoinedAt);
          mealBreakDurationMs += elapsed;
        }

        const fullName = getCurrentFullName() || currentUser.email;
        const optimisticEntry = {
          id: currentUser.uid,
          email: currentUser.email,
          fullName,
          role: sanitizeRoleId(currentEntry.role) || null,
          isOnBreak: currentEntry.isOnBreak ?? false,
          joinedAt: currentEntry.joinedAt ?? null,
          isOnMealBreak: targetState,
          mealJoinedAt: startingMealBreak ? new Date() : null,
          breakCount,
          breakDurationMs,
          mealBreakDurationMs,
          lastBreakAt,
          logDateKey: stats.logDateKey,
        };
        const index = rosterEntries.findIndex((entry) => entry.id === currentUser.uid);
        if (index >= 0) {
          rosterEntries[index] = { ...rosterEntries[index], ...optimisticEntry };
        } else {
          rosterEntries = [...rosterEntries, optimisticEntry];
        }
        selfEntry = optimisticEntry;
        renderLists();

        try {
          await setDoc(
            doc(db, "groups", currentGroupId, "busRoster", currentUser.uid),
            {
              email: currentUser.email,
              fullName,
              role: sanitizeRoleId(optimisticEntry.role) || null,
              isOnBreak: optimisticEntry.isOnBreak ?? false,
              joinedAt: optimisticEntry.joinedAt ?? null,
              isOnMealBreak: targetState,
              mealJoinedAt: targetState ? serverTimestamp() : null,
              breakCount,
              breakDurationMs,
              mealBreakDurationMs,
              lastBreakAt,
              logDateKey: stats.logDateKey,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          setRosterMessage(
            targetState ? "You are on meal break." : "You are back from your meal break."
          );
        } catch (error) {
          console.error("Meal break update failed", error);
          setRosterMessage("Meal break update failed. Please try again.", true);
        } finally {
          isRosterMutating = false;
          updateActionButtons();
        }
      }

      async function updateRoleSelection() {
        if (!roleSelect) return;
        if (!currentUser) {
          setRoleMessage("Sign in to set your role.", true);
          return;
        }
        if (!currentGroupId) {
          setRoleMessage("Wait for your group assignment first.", true);
          return;
        }
        if (isRoleUpdating) return;
        const selectedRole = sanitizeRoleId(roleSelect?.value);
        isRoleUpdating = true;
        setRoleControlsDisabled(true);
        setRoleMessage(selectedRole ? "Updating your role…" : "Clearing your role…");

        const currentEntry =
          rosterEntries.find((entry) => entry.id === currentUser.uid) ?? selfEntry ?? {};
        const fullName = getCurrentFullName() || currentUser.email;
        const stats = getBreakStatsForToday(currentEntry);
        const optimisticEntry = {
          id: currentUser.uid,
          email: currentUser.email,
          fullName,
          role: selectedRole || null,
          isOnBreak: currentEntry.isOnBreak ?? false,
          joinedAt: currentEntry.joinedAt ?? null,
          isOnMealBreak: currentEntry.isOnMealBreak ?? false,
          mealJoinedAt: currentEntry.mealJoinedAt ?? null,
          breakCount: stats.breakCount,
          breakDurationMs: stats.breakDurationMs,
          mealBreakDurationMs: stats.mealBreakDurationMs,
          lastBreakAt: currentEntry.lastBreakAt ?? null,
          logDateKey: stats.logDateKey,
        };
        const index = rosterEntries.findIndex((entry) => entry.id === currentUser.uid);
        if (index >= 0) {
          rosterEntries[index] = { ...rosterEntries[index], ...optimisticEntry };
        } else {
          rosterEntries = [...rosterEntries, optimisticEntry];
        }
        selfEntry = optimisticEntry;
        syncRoleUI(optimisticEntry);
        renderLists();

        try {
          await setDoc(
            doc(db, "groups", currentGroupId, "busRoster", currentUser.uid),
            {
              email: currentUser.email,
              fullName,
              role: selectedRole || null,
              isOnBreak: optimisticEntry.isOnBreak ?? false,
              joinedAt: optimisticEntry.joinedAt ?? null,
              isOnMealBreak: optimisticEntry.isOnMealBreak ?? false,
              mealJoinedAt: optimisticEntry.mealJoinedAt ?? null,
              breakCount: stats.breakCount,
              breakDurationMs: stats.breakDurationMs,
              mealBreakDurationMs: stats.mealBreakDurationMs,
              lastBreakAt: optimisticEntry.lastBreakAt ?? null,
              logDateKey: stats.logDateKey,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          setRoleMessage(selectedRole ? "Role updated." : "Role cleared.");
        } catch (error) {
          console.error("Role update failed", error);
          setRoleMessage("Unable to update your role. Try again.", true);
        } finally {
          isRoleUpdating = false;
          setRoleControlsDisabled(!currentUser || !currentGroupId);
          syncRoleUI(selfEntry);
        }
      }

      function attemptFullNamePrefill() {
        if (authMode !== "register") return;
        const suggestion = recallFullName(emailInput.value.trim());
        if (suggestion && !fullNameInput.value.trim()) {
          fullNameInput.value = suggestion;
        }
      }

      modeButtons.forEach((button) => {
        button.addEventListener("click", () => setAuthMode(button.dataset.authMode));
      });

      setAuthMode("signin");
      populateRoleSelect();

      emailInput.addEventListener("blur", attemptFullNamePrefill);
      emailInput.addEventListener("change", attemptFullNamePrefill);

      if (passwordToggleButton) {
        passwordToggleButton.addEventListener("click", () => {
          setPasswordVisibility(!isPasswordVisible);
          passwordInput?.focus();
        });
      }

      authForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const email = emailInput.value.trim();
        const isRegister = authMode === "register";
        const fullName = isRegister ? sanitizeFullName(fullNameInput.value) : "";
        if (isRegister) {
          fullNameInput.value = fullName;
        }
        const password = passwordInput.value.trim();

        if (!email) {
          setAuthMessage("Enter an email address.", true);
          return;
        }

        if (!password) {
          setAuthMessage("Enter a password.", true);
          return;
        }

        if (isRegister && !fullName) {
          setAuthMessage("Enter your full name.", true);
          return;
        }

        if (isRegister) {
          pendingIdentity = { email, fullName };
          rememberFullName(email, fullName);
        } else {
          pendingIdentity = null;
        }

        try {
          if (isRegister) {
            setAuthMessage("Creating your account…");
            await createUserWithEmailAndPassword(auth, email, password);
            setAuthMessage("Account created. Signing you in…");
          } else {
            setAuthMessage("Signing you in…");
            await signInWithEmailAndPassword(auth, email, password);
            setAuthMessage("Signed in.");
          }
        } catch (error) {
          const friendly =
            typeof error?.code === "string"
              ? error.code.replace("auth/", "").replace(/-/g, " ")
              : "Something went wrong. Try again.";
          setAuthMessage(friendly, true);
          pendingIdentity = null;
        }
      });

      joinButton.addEventListener("click", () => updateBreakStatus(true));
      leaveButton.addEventListener("click", () => updateBreakStatus(false));
      mealJoinButton.addEventListener("click", () => updateMealBreakStatus(true));
      mealLeaveButton.addEventListener("click", () => updateMealBreakStatus(false));
      if (roleSaveButton) {
        roleSaveButton.addEventListener("click", updateRoleSelection);
      }
      if (roleSelect) {
        roleSelect.addEventListener("change", () => setRoleMessage(""));
      }

      signOutButton.addEventListener("click", async () => {
        try {
          await signOut(auth);
          setAuthMessage("Signed out.");
        } catch {
          setAuthMessage("Unable to sign out. Try again.", true);
        }
      });
      if (adminSignOutButton) {
        adminSignOutButton.addEventListener("click", () => signOutButton.click());
      }
      if (resetAllLogsButton) {
        resetAllLogsButton.addEventListener("click", () => {
          if (!isAdmin || isResettingLogs) return;
          const confirmed = requestResetConfirmation(
            resetAllLogsButton,
            "Click again to reset all logs"
          );
          if (confirmed) {
            resetLogsForGroups(Object.keys(GROUPS));
          }
        });
      }
      if (resetSelectedLogsButton) {
        resetSelectedLogsButton.addEventListener("click", () => {
          if (!isAdmin || isResettingLogs || selectedLogGroups.size === 0) return;
          const confirmed = requestResetConfirmation(
            resetSelectedLogsButton,
            "Click again to reset selected"
          );
          if (confirmed) {
            resetLogsForGroups([...selectedLogGroups]);
          }
        });
      }

      onAuthStateChanged(auth, async (user) => {
        currentUser = user;
        const adminStatus = user ? isAdminAccount(user) : false;
        setAdminMode(adminStatus);

        if (user) {
          userEmailEl.textContent = user.email;
          setRosterMessage("");
          setGroupMessage(adminStatus ? "Break overview" : "Looking up your group…");
          setRoleMessage(adminStatus ? "" : "Choose where you're working today.");
          setRoleControlsDisabled(true);
          try {
            if (pendingIdentity && pendingIdentity.email === user.email) {
              await saveProfileFullName(user, pendingIdentity.fullName);
              rememberFullName(user.email, pendingIdentity.fullName);
            } else {
              const profile = await fetchProfile(user);
              currentProfile = profile?.fullName
                ? { fullName: sanitizeFullName(profile.fullName) }
                : { fullName: "" };
              if (!currentProfile.fullName) {
                const suggestion = recallFullName(user.email);
                if (suggestion) {
                  currentProfile.fullName = suggestion;
                  rememberFullName(user.email, suggestion);
                } else {
                  setAuthMessage("Add your full name when signing in next time.", true);
                }
              } else {
                rememberFullName(user.email, currentProfile.fullName);
              }
            }
          } catch {
            setAuthMessage("Unable to sync your full name. Try again.", true);
          } finally {
            pendingIdentity = null;
          }

          if (adminStatus) {
            startAdminRosterWatchers();
            stopGroupWatcher();
            stopRosterSubscription();
            currentGroupId = null;
          } else {
            stopAdminRosterWatchers();
            startGroupWatcher(user);
          }
        } else {
          userEmailEl.textContent = "—";
          setRosterMessage("");
          setGroupMessage("");
          setRoleMessage("");
          currentGroupId = null;
          currentProfile = { fullName: "" };
          pendingIdentity = null;
          stopGroupWatcher();
          stopRosterSubscription();
          stopAdminRosterWatchers();
          setAdminMode(false);
          setRoleControlsDisabled(true);
          syncRoleUI(null);
        }

        toggleViews(Boolean(user));
        renderLists();
        renderAdminPanel();
        document.body.classList.remove("app-loading");
      });

      renderLists();
    </script>
  </body>
</html>
