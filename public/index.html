<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Trend ISG</title>
    <link rel="icon" type="image/png" sizes="512x512" href="indapentx.png" />
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --bg: #ffffff;
        --surface: #f4f4f4;
        --card: #ffffff;
        --text: #111111;
        --subtle: #6b6b6b;
        --border: #e3e3e3;
        --accent: #111111;
      }

      * {
        box-sizing: border-box;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      body {
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        margin: 0;
        padding: 2rem 1.5rem 3rem;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      main {
        width: min(960px, 100%);
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      header {
        text-align: left;
      }

      .header-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
        flex-wrap: wrap;
      }

      .language-switch {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        align-items: flex-start;
      }

      .language-switch.inline {
        flex-direction: row;
        align-items: center;
        gap: 0.65rem;
      }

      .language-switch.inline select {
        min-width: 180px;
      }

      .language-label {
        font-size: 0.85rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: var(--subtle);
        font-weight: 700;
      }

      h1 {
        margin: 0 0 0.35rem;
        font-size: clamp(2rem, 4vw, 2.5rem);
        letter-spacing: -0.02em;
      }

      header p {
        margin: 0;
        color: var(--subtle);
        max-width: 52ch;
      }

      .site-footer {
        width: min(960px, 100%);
        margin-top: 1.5rem;
        padding: 1.2rem 1.4rem;
        border: 1px solid var(--border);
        border-radius: 20px;
        background: var(--card);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }

      .footer-meta {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .footer-title {
        margin: 0;
        font-weight: 700;
      }

      .footer-note {
        margin: 0;
        color: var(--subtle);
        font-size: 0.95rem;
      }

      .footer-actions {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 20px;
        padding: 1.75rem;
        box-shadow: 0 20px 40px rgba(17, 17, 17, 0.03);
      }

      .auth-card form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .auth-toggle {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.35rem;
        background: var(--surface);
        padding: 0.25rem;
        border-radius: 999px;
        border: 1px solid var(--border);
      }

      .auth-toggle button {
        border: none;
        background: transparent;
        color: var(--subtle);
        font-weight: 600;
        border-radius: 999px;
        padding: 0.65rem 0.5rem;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .auth-toggle button.active {
        background: var(--card);
        color: var(--text);
        box-shadow: 0 6px 12px rgba(17, 17, 17, 0.08);
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--subtle);
      }

      input {
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0.85rem 1.1rem;
        font-size: 1rem;
        background: var(--surface);
        color: var(--text);
      }

      input:focus-visible {
        outline: 2px solid var(--text);
        outline-offset: 2px;
      }

      select {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 0.85rem 1rem;
        font-size: 1rem;
        background: var(--surface);
        color: var(--text);
        min-width: 220px;
      }

      select:focus-visible {
        outline: 2px solid var(--text);
        outline-offset: 2px;
      }

      .form-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 0.85rem 1.4rem;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        background: var(--accent);
        color: var(--bg);
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      button.ghost {
        background: transparent;
        color: var(--text);
        border: 1px solid var(--border);
      }

      button.confirm {
        background: #b3261e;
        color: #ffffff;
        border-color: #b3261e;
      }

      button.ghost.confirm {
        border-color: #b3261e;
      }

      button:disabled {
        opacity: 0.35;
        cursor: not-allowed;
      }

      button:not(:disabled):hover {
        opacity: 0.9;
      }

      .muted {
        color: var(--subtle);
        font-size: 0.9rem;
        margin: 0;
        min-height: 1.25rem;
      }

      .muted:empty {
        display: none;
      }

      .field-hint {
        font-size: 0.8rem;
        color: var(--subtle);
      }

      #auth-message {
        margin-top: 1rem;
      }

      .full-name-field.hidden {
        display: none;
      }

      .password-input {
        position: relative;
      }

      .password-input input {
        width: 100%;
        padding-right: 4.75rem;
      }

      .password-visibility {
        position: absolute;
        right: 0.35rem;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        color: var(--text);
        padding: 0.35rem 0.75rem;
        font-size: 0.85rem;
        font-weight: 600;
        border: none;
      }

      .password-visibility:hover {
        opacity: 0.7;
      }

      .password-visibility:focus-visible {
        outline: 2px solid var(--text);
        outline-offset: 3px;
      }

      .muted.error {
        color: #b3261e;
      }

      .dashboard {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .user-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .role-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 1rem;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 1rem;
        background: var(--surface);
      }

      .role-meta {
        flex: 1 1 200px;
        min-width: 200px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 0.2rem;
      }

      .role-current {
        margin: 0;
        font-size: 1.1rem;
        letter-spacing: -0.01em;
        font-weight: 600;
      }

      .role-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.65rem;
        align-items: center;
      }

      .role-actions button {
        white-space: nowrap;
      }

      .info-card {
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
      }

      #work-info.card {
        box-shadow: none;
        border-radius: 20px;
        border-color: var(--border);
        padding: 1.75rem;
      }

      .info-heading {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
      }

      .info-title-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
      }

      .info-toggle {
        padding: 0.45rem 0.9rem;
        font-size: 0.85rem;
        white-space: nowrap;
      }

      .info-heading h2,
      .user-email {
        margin: 0;
        font-size: 1.35rem;
        font-weight: 700;
        letter-spacing: -0.01em;
      }

      .info-grid {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .info-section {
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1rem;
        background: var(--surface);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .info-section.departments-section {
        border: 0;
        background: transparent;
        padding: 0;
        gap: 1rem;
      }

      .info-section-title {
        margin: 0;
        font-weight: 700;
        letter-spacing: -0.01em;
      }

      .info-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.9rem;
      }

      .info-item {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        padding: 1rem;
        border-radius: 16px;
        background: var(--surface);
        border: 1px solid var(--border);
      }

      .info-item-header {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }

      .info-item-title {
        margin: 0;
        font-weight: 700;
        letter-spacing: -0.01em;
        font-size: 1.05rem;
      }

      .info-item-desc {
        margin: 0;
        color: var(--subtle);
      }

      .dept-faq {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      #work-info.faqs-collapsed .dept-faq {
        display: none;
      }

      .faq-row {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 0.9rem 1rem;
        background: var(--card);
        box-shadow: none;
      }

      .faq-question {
        font-weight: 600;
        margin: 0;
      }

      .faq-answer {
        margin: 0.15rem 0 0;
        color: var(--subtle);
      }

      .shift-table {
        width: 100%;
        border-collapse: collapse;
      }

      .shift-table th,
      .shift-table td {
        text-align: left;
        padding: 0.65rem 0.25rem;
        border-bottom: 1px solid var(--border);
      }

      .shift-table th {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--subtle);
      }

      .shift-table tr:last-child td {
        border-bottom: 0;
        padding-bottom: 0;
      }


      .eyebrow {
        text-transform: uppercase;
        font-size: 0.75rem;
        letter-spacing: 0.15em;
        color: var(--subtle);
        margin: 0;
      }

      .lists {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1rem;
      }

      .list-column {
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1.2rem;
        background: var(--surface);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .list-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
      }

      h2 {
        margin: 0;
        font-size: 1.1rem;
        letter-spacing: -0.01em;
      }

      .status-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: stretch;
      }

      .status-list li {
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--card);
        padding: 0.9rem 1rem;
        font-weight: 500;
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        align-items: center;
        width: 100%;
        min-height: 68px;
      }

      .status-list .empty {
        color: var(--subtle);
        font-weight: 400;
        font-size: 0.95rem;
        justify-content: flex-start;
      }

      .person {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
      }

      .person-name {
        font-weight: 600;
      }

      .person-email {
        font-size: 0.85rem;
        color: var(--subtle);
        font-weight: 400;
      }

      .person-role {
        font-size: 0.85rem;
        color: var(--subtle);
        font-weight: 500;
      }

      .time-badge {
        font-size: 0.8rem;
        font-weight: 500;
        color: var(--subtle);
      }

      .hidden {
        display: none;
      }

      .admin-panel {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .admin-panel.hidden {
        display: none;
      }

      .admin-groups {
        display: grid;
        grid-template-columns: 1fr;
        gap: 0.65rem;
      }

      .group-chip-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        overflow-x: auto;
        padding: 0.15rem 0.05rem;
      }

      .group-chip {
        padding: 0.35rem 0.9rem;
        font-size: 0.85rem;
        white-space: nowrap;
        flex: 0 0 auto;
      }

      .group-chip.active {
        background: var(--accent);
        color: var(--bg);
        border-color: var(--accent);
      }

      .admin-group-card {
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1rem;
        background: var(--surface);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .admin-group-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .admin-toggle {
        padding: 0.45rem 0.9rem;
        font-size: 0.85rem;
      }

      .admin-group-card h3 {
        margin: 0;
        letter-spacing: -0.01em;
        text-transform: capitalize;
      }

      .admin-group-card .status-list {
        background: transparent;
      }

      .admin-group-body {
        display: grid;
        grid-template-columns: 1fr;
        gap: 0.75rem;
      }

      .admin-group-column {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-width: 0;
      }

      .admin-group-card.minimized {
        opacity: 0.9;
      }

      .admin-group-card.minimized .admin-group-body {
        display: none;
      }

      .admin-group-divider {
        height: 1px;
        width: 100%;
        background: var(--border);
      }

      .admin-group-divider-stack {
        grid-column: 1 / -1;
      }

      @media (min-width: 768px) {
        .admin-group-body {
          grid-template-columns: repeat(2, minmax(0, 1fr));
          gap: 1rem;
        }

        .admin-group-divider-stack {
          display: none;
        }
      }

      .admin-logs {
        margin-top: 1rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .logs-header {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .logs-footer {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        align-items: flex-start;
      }

      .logs-heading {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .logs-actions {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
        width: 100%;
      }

      .log-reset-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }

      .log-group-select {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .log-option {
        border: 1px solid var(--border);
        background: var(--surface);
        border-radius: 999px;
        padding: 0.35rem 0.75rem;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-weight: 600;
        font-size: 0.9rem;
      }

      .log-option input {
        margin: 0;
      }

      .log-table {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 1rem;
      }

      .log-table.focus-mode {
        gap: 0.65rem;
      }

      .log-card {
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1rem;
        background: var(--surface);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .log-card.minimized {
        opacity: 0.9;
      }

      .log-card.minimized .log-card-body {
        display: none;
      }

      .log-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .log-card h3 {
        margin: 0;
        letter-spacing: -0.01em;
        text-transform: capitalize;
      }

      .log-card table {
        width: 100%;
        border-collapse: collapse;
      }

      .log-card th,
      .log-card td {
        text-align: left;
        padding: 0.45rem 0.25rem;
        border-bottom: 1px solid var(--border);
      }

      .log-card th {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: var(--subtle);
      }

      .log-card tr:last-child td {
        border-bottom: none;
        padding-bottom: 0;
      }

      .log-empty {
        color: var(--subtle);
        margin: 0.25rem 0;
        font-size: 0.95rem;
      }

      body.app-loading {
        position: relative;
      }

      body.app-loading main {
        visibility: hidden;
      }

      body.app-loading .site-footer {
        visibility: hidden;
      }

      body.app-loading::before {
        content: attr(data-loading-label);
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--bg);
        color: var(--subtle);
        font-size: 0.95rem;
      }

      @media (max-width: 640px) {
        body {
          padding: 0.9rem;
        }

        main {
          gap: 1rem;
        }

        .card {
          padding: 1.25rem;
        }

        #work-info.card {
          padding: 1.25rem;
        }

        .site-footer {
          align-items: flex-start;
          flex-direction: column;
          padding: 1rem;
        }

        .footer-actions {
          width: 100%;
        }

        .language-switch.inline {
          width: 100%;
        }

        .language-switch.inline select {
          width: 100%;
        }

        .lists {
          gap: 0.75rem;
        }

        .list-column {
          padding: 0.9rem;
          border-radius: 14px;
        }

        .form-actions {
          flex-direction: column;
        }

        .user-row {
          flex-direction: column;
          align-items: flex-start;
        }

        .role-actions {
          width: 100%;
        }

        .log-card table,
        .log-card tbody {
          display: block;
          width: 100%;
        }

        .log-card thead {
          display: none;
        }

        .log-card tr {
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 0.4rem;
          padding: 0.75rem 0;
          border-bottom: 1px solid var(--border);
        }

        .log-card tr:last-child {
          border-bottom: none;
        }

        .log-card tr:last-child td {
          padding-bottom: 0;
        }

        .log-card td {
          display: flex;
          justify-content: space-between;
          align-items: flex-start;
          gap: 0.75rem;
          padding: 0;
          border: 0;
          width: 100%;
          font-size: 0.95rem;
          line-height: 1.3;
        }

        .log-card td::before {
          content: attr(data-label);
          font-size: 0.78rem;
          text-transform: uppercase;
          letter-spacing: 0.08em;
          color: var(--subtle);
          font-weight: 700;
        }
      }
    </style>
  </head>
  <body class="app-loading" data-loading-label="Loading…">
    <main>
      <header id="site-header">
        <div class="header-top">
          <div>
            <h1 id="app-title">Break Status</h1>
            <p id="app-tagline">Made by Furkan Öztürk for Trend ISG.</p>
          </div>
        </div>
      </header>

      <section class="card auth-card" id="auth-card">
        <form id="auth-form" autocomplete="on">
          <div class="auth-toggle" role="tablist" aria-label="Authentication mode">
            <button type="button" data-auth-mode="signin" class="active" aria-pressed="true">
              Sign In
            </button>
            <button type="button" data-auth-mode="register" aria-pressed="false">
              Create Account
            </button>
          </div>
          <label>
            <span class="label-text" id="email-label">Email</span>
            <input type="email" id="email" name="email" placeholder="saul@email.com" required />
          </label>
          <div class="full-name-field hidden" id="full-name-field">
            <label>
              <span class="label-text" id="full-name-label">Full name</span>
              <input
                type="text"
                id="full-name"
                name="fullName"
                placeholder="Saul Goodman"
                autocomplete="name"
              />
            </label>
          </div>
          <label>
            <span class="label-text" id="password-label">Password</span>
            <div class="password-input">
              <input
                type="password"
                id="password"
                name="password"
                minlength="6"
                placeholder="Minimum 6 characters"
                required
              />
              <button
                type="button"
                class="password-visibility"
                id="password-visibility"
                aria-pressed="false"
              >
                Show
              </button>
            </div>
          </label>
        <div class="form-actions">
          <button type="submit" id="auth-submit">Sign In</button>
        </div>
      </form>
        <p class="muted" id="auth-message"></p>
      </section>

      <section class="card dashboard hidden" id="dashboard">
        <div class="user-row">
          <div>
            <p class="eyebrow" id="signed-in-label">Signed in as</p>
            <p class="user-email" id="user-email">—</p>
          </div>
          <button class="ghost" id="sign-out">Sign Out</button>
        </div>

        <div class="role-row" id="role-row">
          <div class="role-meta">
            <h2 class="role-current" id="role-current">No role selected</h2>
            <p class="muted" id="role-message"></p>
          </div>
          <div class="role-actions">
            <label class="sr-only" for="role-select">Choose your role</label>
            <select id="role-select">
              <option value="">Choose a role…</option>
            </select>
            <button type="button" id="role-save">Update role</button>
          </div>
        </div>

        <div class="lists">
          <div class="list-column">
            <div class="list-header">
              <h2 id="on-break-heading">On break</h2>
              <button id="leave-btn" class="ghost" type="button" disabled>Return</button>
            </div>
            <ul class="status-list" id="on-break">
              <li class="empty">Sign in to see the break list.</li>
            </ul>
          </div>
          <div class="list-column">
            <div class="list-header">
              <h2 id="working-heading">Working</h2>
              <button id="join-btn" type="button" disabled>Start break</button>
            </div>
            <ul class="status-list" id="off-break">
              <li class="empty">Sign in to see the break list.</li>
            </ul>
          </div>
        </div>
        <div class="lists">
          <div class="list-column">
            <div class="list-header">
              <h2 id="on-meal-heading">On meal break</h2>
              <button id="meal-leave-btn" class="ghost" type="button" disabled>End meal</button>
            </div>
            <ul class="status-list" id="on-meal-break">
              <li class="empty">Sign in to see the meal break list.</li>
            </ul>
          </div>
          <div class="list-column">
            <div class="list-header">
              <h2 id="off-meal-heading">Not on meal break</h2>
              <button id="meal-join-btn" type="button" disabled>Start meal</button>
            </div>
            <ul class="status-list" id="off-meal-break">
              <li class="empty">Sign in to see the meal break list.</li>
            </ul>
          </div>
        </div>
        <p class="muted" id="roster-message"></p>
        <p class="muted" id="group-message"></p>
      </section>

      <section class="card admin-panel hidden" id="admin-panel">
        <div class="user-row">
          <div>
            <p class="eyebrow" id="admin-staff-label">Staff view</p>
            <p class="user-email" id="admin-user-email">—</p>
          </div>
          <button class="ghost" id="admin-sign-out">Sign Out</button>
        </div>
        <div class="admin-groups" id="admin-groups">
          <p class="muted">Loading group data…</p>
        </div>
        <div class="admin-logs" id="admin-logs">
          <div class="logs-header">
            <div class="logs-heading">
              <p class="eyebrow" id="logs-heading-title">Break logs</p>
            </div>
          </div>
          <div class="log-table" id="log-table">
            <p class="muted">Loading logs…</p>
          </div>
          <div class="logs-footer">
            <div class="logs-actions">
            <div class="log-group-select" id="log-group-select" aria-label="Select groups to reset">
              <p class="muted">Loading groups…</p>
            </div>
            <div class="log-reset-actions">
              <div class="log-group-select" id="log-export-scope">
                <label class="log-option">
                  <input type="radio" name="export-scope" value="all" checked />
                  <span>All groups</span>
                </label>
                <label class="log-option">
                  <input type="radio" name="export-scope" value="selected" />
                  <span>Selected groups</span>
                </label>
              </div>
              <button class="ghost" type="button" id="export-logs">
                Export
              </button>
              <button class="ghost" type="button" id="reset-selected-logs" disabled>
                Reset selected groups
                </button>
                <button type="button" id="reset-all-logs">Reset all</button>
              </div>
            </div>
            <p class="muted hidden" id="logs-message"></p>
          </div>
        </div>
      </section>

      <section class="card info-card" id="work-info">
        <div class="info-heading">
          <p class="eyebrow" id="info-eyebrow">Ops guide</p>
          <div class="info-title-row">
            <h2 id="info-title">Departments & FAQs</h2>
            <button
              class="ghost info-toggle"
              type="button"
              id="info-faq-toggle"
              aria-controls="department-list"
              aria-pressed="false"
              aria-expanded="true"
            >
              Collapse
            </button>
          </div>
        </div>
        <div class="info-grid">
          <div class="info-section departments-section">
            <p class="info-section-title sr-only">Departments & FAQs</p>
            <ul class="info-list" id="department-list"></ul>
          </div>
          <div class="info-section shift-section">
            <p class="info-section-title" id="meal-shift-title">Day / night meal breaks</p>
            <table class="shift-table" aria-label="Meal break times">
              <thead>
                <tr>
                  <th scope="col" id="meal-shift-header">Shift</th>
                  <th scope="col" id="meal-window-header">Meal break</th>
                </tr>
              </thead>
              <tbody id="meal-shifts"></tbody>
            </table>
          </div>
        </div>
      </section>
    </main>

    <footer class="site-footer">
      <div class="footer-meta">
        <p class="footer-title">Trend ISG</p>
        <p class="footer-note" id="footer-note">Choose your preferred language for the app.</p>
      </div>
      <div class="footer-actions">
        <label class="language-switch inline" for="language-select-footer">
          <span class="language-label">Language</span>
          <select
            id="language-select-footer"
            data-language-picker
            aria-label="Language selection"
          >
            <option value="en">English</option>
            <option value="tr">Türkçe</option>
          </select>
        </label>
      </div>
    </footer>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
      import {
        getAuth,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        createUserWithEmailAndPassword,
        signOut,
      } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
      import {
        getFirestore,
        doc,
        setDoc,
        getDoc,
        getDocs,
        collection,
        onSnapshot,
        serverTimestamp,
        writeBatch,
        runTransaction,
      } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDHZz5fVOTvnokTuTUjNSC5QSiC7mFxyZM",
        authDomain: "trend-isg.firebaseapp.com",
        projectId: "trend-isg",
        storageBucket: "trend-isg.firebasestorage.app",
        messagingSenderId: "751472868865",
        appId: "1:751472868865:web:eb6702b74236d19913ca00",
      };

      const LANGUAGE_OPTIONS = Object.freeze([
        { value: "en", label: "English" },
        { value: "tr", label: "Türkçe" },
      ]);

      const COPY = Object.freeze({
        en: {
          languageLabel: "Language",
          loading: "Loading…",
          header: {
            title: "Break Status",
            tagline: "Made by Furkan Öztürk for Trend ISG.",
          },
          auth: {
            tabSignIn: "Sign In",
            tabRegister: "Create Account",
            emailLabel: "Email",
            emailPlaceholder: "saul@email.com",
            fullNameLabel: "Full name",
            fullNamePlaceholder: "Saul Goodman",
            passwordLabel: "Password",
            passwordPlaceholder: "Minimum 6 characters",
            show: "Show",
            hide: "Hide",
            submitSignIn: "Sign In",
            submitRegister: "Create Account",
            defaultMessage: "Use your credentials to access the break list.",
            ariaAuthMode: "Authentication mode",
          },
          dashboard: {
            signedInAs: "Signed in as",
            signOut: "Sign Out",
            rolePlaceholder: "Choose a role…",
            updateRole: "Update role",
            groupLabel: "Group: {group}",
            breakOverview: "Break overview",
            lookingUpGroup: "Looking up your group…",
            chooseRolePrompt: "Choose where you're working today.",
            noRoleSelected: "No role selected",
            roleLabel: "Choose your role",
          },
          lists: {
            onBreak: "On break",
            working: "Working",
            onMealBreak: "On meal break",
            offMealBreak: "Not on meal break",
            leave: "Return",
            join: "Start break",
            mealLeave: "End meal",
            mealJoin: "Start meal",
            signInBreak: "Sign in to see the break list.",
            signInMeal: "Sign in to see the meal break list.",
            awaitingGroup: "Waiting for a group assignment.",
            noAssignments: "No one is assigned to this group yet.",
            nobodyOnBreak: "Nobody is on break right now.",
            nobodyWorking: "Nobody is working right now.",
            nobodyMeal: "Nobody is on meal break right now.",
            everyoneMeal: "Everyone is on meal break.",
          },
          admin: {
            staffView: "Staff view",
            loadingGroups: "Loading group data…",
            loadingLogs: "Loading logs…",
            logsHeading: "Break logs",
            exportCsv: "Export",
            allGroups: "all groups",
            showAll: "Show all",
            resetSelected: "Reset selected groups",
            resetAll: "Reset all",
            resetAllConfirm: "Click again to reset all logs",
            resetSelectedConfirm: "Click again to reset selected",
            groupLabel: "Group {group}",
            exportScopeAll: "All groups",
            exportScopeSelected: "Selected groups",
            noGroups: "No groups configured.",
            noUsers: "No users in this group yet.",
            collapse: "Collapse",
            expand: "Expand",
            selectGroupsLabel: "Select groups to reset",
          },
          info: {
            eyebrow: "Ops guide",
            title: "Departments & FAQs",
            mealTitle: "Day / night meal breaks",
            shift: "Shift",
            meal: "Meal break",
            collapse: "Collapse",
            expand: "Expand",
            collapseFaqsLabel: "Collapse all FAQs",
            expandFaqsLabel: "Expand all FAQs",
          },
          footer: {
            note: "Choose your preferred language.",
          },
          logTable: {
            worker: "Worker",
            role: "Role",
            breaks: "Breaks",
            timeOnBreak: "Time on break",
            timeOnMeal: "Time on meal break",
            lastBreak: "Last break",
          },
          persons: {
            unknown: "Unknown worker",
            roleNotSet: "Role not set",
          },
          messages: {
            emailRequired: "Enter an email address.",
            passwordRequired: "Enter a password.",
            fullNameRequired: "Enter your full name.",
            creatingAccount: "Creating your account…",
            accountCreated: "Account created. Signing you in…",
            signingIn: "Signing you in…",
            signedIn: "Signed in.",
            authErrorFallback: "Something went wrong. Try again.",
            signedOut: "Signed out.",
            signOutError: "Unable to sign out. Try again.",
            addFullNameLater: "Add your full name when signing in next time.",
            syncFullNameFailed: "Unable to sync your full name. Try again.",
            rosterSlotIssue: "Unable to prepare your roster slot.",
            rosterPaused: "Live roster updates paused. Refresh the page.",
            loadGroupError: "Unable to load your group.",
            noGroupAssigned: "No group assigned. Contact the owner.",
            invalidGroup: "Invalid group assignment. Contact the owner.",
            roleAfterGroup: "Role selection will be available after you get a group.",
            roleAfterValidGroup: "Role selection will be available after you get a valid group.",
            needGroupBreak: "You need a group before updating break status.",
            needGroupMeal: "You need a group before updating meal break status.",
            selectRoleFirst: "Select your role before updating your break.",
            endMealFirst: "End your meal break first.",
            endBreakFirst: "End your regular break first.",
            startingBreak: "Starting your break…",
            endingBreak: "Ending your break…",
            onBreak: "You are on break.",
            backFromBreak: "You are back from break.",
            breakUpdateFailed: "Update failed. Please try again.",
            startingMeal: "Starting your meal break…",
            endingMeal: "Ending your meal break…",
            onMeal: "You are on meal break.",
            backFromMeal: "You are back from your meal break.",
            mealUpdateFailed: "Meal break update failed. Please try again.",
            signInSetRole: "Sign in to set your role.",
            waitForGroup: "Wait for your group assignment first.",
            updatingRole: "Updating your role…",
            clearingRole: "Clearing your role…",
            roleUpdated: "Role updated.",
            roleCleared: "Role cleared.",
            roleUpdateFailed: "Unable to update your role. Try again.",
            resettingLogs: "Resetting logs for {label}…",
            logsReset: "Logs reset for {label}.",
            resetLogsFailed: "Unable to reset logs. Try again.",
            exportNoData: "No logs to export yet.",
            exportFailed: "Unable to export logs. Try again.",
            exportReady: "CSV downloaded.",
            groupAwaiting: "Waiting for a group assignment.",
            authDefault: "Use your credentials to access the break list.",
            breakOverview: "Break overview",
          },
          time: {
            hour: "h",
            minute: "m",
            day: "d",
            lessThanMinute: "<1m",
            ago: "ago",
            fromNow: "from now",
          },
        },
        tr: {
          languageLabel: "Dil",
          loading: "Yükleniyor…",
          header: {
            title: "Mola Durumu",
            tagline: "Trend ISG için Furkan Öztürk tarafından yapıldı.",
          },
          auth: {
            tabSignIn: "Giriş yap",
            tabRegister: "Hesap oluştur",
            emailLabel: "E-posta",
            emailPlaceholder: "saul@email.com",
            fullNameLabel: "Ad soyad",
            fullNamePlaceholder: "Saul Goodman",
            passwordLabel: "Şifre",
            passwordPlaceholder: "Minimum 6 karakter",
            show: "Göster",
            hide: "Gizle",
            submitSignIn: "Giriş yap",
            submitRegister: "Hesap oluştur",
            defaultMessage: "Mola listesine erişmek için bilgilerinizi girin.",
            ariaAuthMode: "Kimlik doğrulama modu",
          },
          dashboard: {
            signedInAs: "Giriş yapan",
            signOut: "Çıkış yap",
            rolePlaceholder: "Rol seçin…",
            updateRole: "Rolü güncelle",
            groupLabel: "Grup: {group}",
            breakOverview: "Mola genel görünümü",
            lookingUpGroup: "Grubunuz aranıyor…",
            chooseRolePrompt: "Bugün nerede çalıştığınızı seçin.",
            noRoleSelected: "Rol seçilmedi",
            roleLabel: "Rolünüzü seçin",
          },
          lists: {
            onBreak: "Molada",
            working: "Çalışıyor",
            onMealBreak: "Yemekte",
            offMealBreak: "Yemekte değil",
            leave: "Moladan dön",
            join: "Molaya çık",
            mealLeave: "Yemekten dön",
            mealJoin: "Yemeğe çık",
            signInBreak: "Mola listesini görmek için giriş yapın.",
            signInMeal: "Yemek mola listesini görmek için giriş yapın.",
            awaitingGroup: "Grup ataması bekleniyor.",
            noAssignments: "Bu gruba henüz kimse atanmadı.",
            nobodyOnBreak: "Şu anda molada kimse yok.",
            nobodyWorking: "Şu anda çalışan kimse yok.",
            nobodyMeal: "Şu anda yemek molasında kimse yok.",
            everyoneMeal: "Herkes yemek molasında.",
          },
          admin: {
            staffView: "Yönetici görünümü",
            loadingGroups: "Grup verileri yükleniyor…",
            loadingLogs: "Kayıtlar yükleniyor…",
            logsHeading: "Mola kayıtları",
            exportCsv: "Dışa aktar",
            allGroups: "tüm gruplar",
            showAll: "Tümünü göster",
            resetSelected: "Seçili grupları sıfırla",
            resetAll: "Tümünü sıfırla",
            resetAllConfirm: "Tüm kayıtları sıfırlamak için tekrar tıklayın",
            resetSelectedConfirm: "Seçilileri sıfırlamak için tekrar tıklayın",
            groupLabel: "Grup {group}",
            exportScopeAll: "Tüm gruplar",
            exportScopeSelected: "Seçili gruplar",
            noGroups: "Henüz tanımlı grup yok.",
            noUsers: "Bu grupta henüz kullanıcı yok.",
            collapse: "Daralt",
            expand: "Genişlet",
            selectGroupsLabel: "Sıfırlanacak grupları seçin",
          },
          info: {
            eyebrow: "Operasyon rehberi",
            title: "Departmanlar ve SSS",
            mealTitle: "Gündüz / gece yemek araları",
            shift: "Vardiya",
            meal: "Yemek arası",
            collapse: "Daralt",
            expand: "Genişlet",
            collapseFaqsLabel: "Tüm SSS'leri daralt",
            expandFaqsLabel: "Tüm SSS'leri genişlet",
          },
          footer: {
            note: "Tercih ettiğiniz dili buradan seçin.",
          },
          logTable: {
            worker: "Personel",
            role: "Rol",
            breaks: "Mola",
            timeOnBreak: "Mola süresi",
            timeOnMeal: "Yemek molası süresi",
            lastBreak: "Son mola",
          },
          persons: {
            unknown: "Bilinmeyen personel",
            roleNotSet: "Rol seçilmedi",
          },
          messages: {
            emailRequired: "Bir e-posta adresi girin.",
            passwordRequired: "Bir şifre girin.",
            fullNameRequired: "Adınızı ve soyadınızı girin.",
            creatingAccount: "Hesabınız oluşturuluyor…",
            accountCreated: "Hesap oluşturuldu. Giriş yapılıyor…",
            signingIn: "Giriş yapılıyor…",
            signedIn: "Giriş yapıldı.",
            authErrorFallback: "Bir sorun oluştu. Lütfen tekrar deneyin.",
            signedOut: "Çıkış yapıldı.",
            signOutError: "Çıkış yapılamadı. Tekrar deneyin.",
            addFullNameLater: "Bir dahaki girişinizde ad soyad ekleyin.",
            syncFullNameFailed: "Ad soyad eşitlenemedi. Tekrar deneyin.",
            rosterSlotIssue: "Kayıt alanınız hazırlanamadı.",
            rosterPaused: "Canlı liste durdu. Sayfayı yenileyin.",
            loadGroupError: "Grubunuz yüklenemedi.",
            noGroupAssigned: "Grup ataması yok. İlgili kişiye bildirin.",
            invalidGroup: "Geçersiz grup ataması. İlgili kişiye bildirin.",
            roleAfterGroup: "Rol seçimi grup ataması sonrası açılacak.",
            roleAfterValidGroup: "Geçerli bir grup sonrası rol seçimi açılacak.",
            needGroupBreak: "Mola durumunu güncellemek için bir gruba ihtiyacınız var.",
            needGroupMeal: "Yemek molasını güncellemek için bir gruba ihtiyacınız var.",
            selectRoleFirst: "Molanızı güncellemeden önce rol seçin.",
            endMealFirst: "Önce yemek molasını bitirin.",
            endBreakFirst: "Önce normal molayı bitirin.",
            startingBreak: "Molanız başlatılıyor…",
            endingBreak: "Molanız bitiriliyor…",
            onBreak: "Moladasınız.",
            backFromBreak: "Moladan döndünüz.",
            breakUpdateFailed: "Güncelleme başarısız. Tekrar deneyin.",
            startingMeal: "Yemek molanız başlatılıyor…",
            endingMeal: "Yemek molanız bitiriliyor…",
            onMeal: "Yemek molasındasınız.",
            backFromMeal: "Yemek molasından döndünüz.",
            mealUpdateFailed: "Yemek molası güncellemesi başarısız. Tekrar deneyin.",
            signInSetRole: "Rolünüzü seçmek için giriş yapın.",
            waitForGroup: "Önce grup atamasını bekleyin.",
            updatingRole: "Rolünüz güncelleniyor…",
            clearingRole: "Rolünüz temizleniyor…",
            roleUpdated: "Rol güncellendi.",
            roleCleared: "Rol temizlendi.",
            roleUpdateFailed: "Rol güncellenemedi. Tekrar deneyin.",
            resettingLogs: "{label} için kayıtlar sıfırlanıyor…",
            logsReset: "{label} için kayıtlar sıfırlandı.",
            resetLogsFailed: "Kayıtlar sıfırlanamadı. Tekrar deneyin.",
            exportNoData: "Dışa aktarılacak kayıt yok.",
            exportFailed: "Kayıtlar dışa aktarılamadı. Tekrar deneyin.",
            exportReady: "CSV indirildi.",
            groupAwaiting: "Grup ataması bekleniyor.",
            authDefault: "Mola listesine erişmek için bilgilerinizi girin.",
            breakOverview: "Mola genel görünümü",
          },
          time: {
            hour: "s",
            minute: "dk",
            day: "g",
            lessThanMinute: "<1dk",
            ago: "önce",
            fromNow: "sonra",
          },
        },
      });

      const DEFAULT_LANGUAGE = "en";
      let currentLanguage = DEFAULT_LANGUAGE;
      document.documentElement.lang = currentLanguage;

      const GROUPS = Object.freeze({
        A: "A",
        B: "B",
        C: "C",
        D: "D",
      });

      const ROLE_OPTIONS = Object.freeze([
        { id: "international-departures", labels: { en: "International Departures", tr: "Dış Hatlar" },},
        { id: "domestic-departures", labels: { en: "Domestic Departures", tr: "İç Hatlar" }, },
        { id: "management-office", labels: { en: "Management Office", tr: "Valilik" } },
        { id: "e-passport", labels: { en: "E-passport", tr: "E-pasaport" } },
        { id: "e-passport-arrivals", labels: { en: "E-passport (Arrivals)", tr: "E-pasaport (Gelen)" } },
        { id: "bus-gate", labels: { en: "Bus Gate", tr: "Uzak Uçuş" } },
      ]);

      const DEPARTMENT_DETAILS = Object.freeze([
        {
          id: "international-departures",
          name: { en: "International Departures", tr: "Dış Hatlar" },
          description: {
            en: "Passport control, routing high-risk passengers, balancing queues.",
            tr: "Dış hatlardaki görevimiz, yolcuların biletlerini okutarak güvenli bir şekilde geçiş yapmalarını sağlamaktır.",
          },
          faqs: [
            {
              question: {
                en: "Does nationality matter?",
                tr: "X vatandaşıyım, nereden devam etmeliyim?",
              },
              answer: {
                en: "No, it doesn't matter.",
                tr: "Vatandaşlığınızın bir önemi yok. İstediğiniz taraftan geçebilirsiniz.",
              },
            },
            {
              question: {
                en: "Kıbrıs’a gidiyorum, yurt dışı çıkış harcı ödemem gerekiyor mu?",
                tr: "Kıbrıs’a gidiyorum, yurt dışı çıkış harcı ödemem gerekiyor mu?"
              },
              answer: {
                en: "Kimlikle çıkış yapacaksanız gerekmez. Pasaportla çıkış yapacaksanız gerekir.",
                tr: "Kimlikle çıkış yapacaksanız gerekmez. Pasaportla çıkış yapacaksanız gerekir.",
              },
            },
          ],
        },/*
        {
          id: "domestic-departures",
          name: { en: "Domestic Departures", tr: "İç Hatlar" },
          description: {
            en: "X-ray, boarding gates, and PRM/assisted passenger handling.",
            tr: "X-ray, biniş kapıları ve PRM/yardımlı yolcu yönetimi.",
          },
          faqs: [
            {
              question: { en: "What if cabin baggage is oversized?", tr: "Kabin bagajı büyükse ne yaparız?" },
              answer: {
                en: "Send to the boarding agent; if needed, route back to baggage drop and log the case.",
                tr: "Biniş görevlisine yönlendir; gerekirse bagaj teslimine geri gönder ve olayı kaydet.",
              },
            },
            {
              question: { en: "How do we handle assisted passengers?", tr: "Yardımlı yolcuyu nasıl yönetiriz?" },
              answer: {
                en: "Plan the escort to the gate, inform boarding crew and supervisor, and confirm a hand-off.",
                tr: "Kapıya refakat planı yap, biniş ekibi ve amiri bilgilendir, devir teslimi teyit et.",
              },
            },
          ],
        },
        {
          id: "e-passport",
          name: { en: "E-passport", tr: "E-pasaport" },
          description: {
            en: "Monitor self-service kiosks and clear blocked gates quickly.",
            tr: "Self-servis kioskları izle ve kilitlenen kapıları hızlıca aç.",
          },
          faqs: [
            {
              question: { en: "What if a kiosk locks up?", tr: "Kiosk kilitlenirse ne yaparız?" },
              answer: {
                en: "Perform a short power cycle; if not fixed, call tech with the device number.",
                tr: "Kısa bir kapat/aç yap; düzelmezse cihaz numarasıyla teknik ekibi ara.",
              },
            },
            {
              question: { en: "Reader alarm goes off - what next?", tr: "Okuyucu alarm verirse ne yaparız?" },
              answer: {
                en: "Move the passenger to a manual desk and log the device number in the incident note.",
                tr: "Yolcuyu manuel bankoya yönlendir ve cihaz numarasını vaka notuna yaz.",
              },
            },
          ],
        },
        {
          id: "bus-gate",
          name: { en: "Bus Gate", tr: "Otobüs Kapısı" },
          description: {
            en: "Gate-to-bus sync, mass guidance, and headcounts.",
            tr: "Kapı-otobüs eşlemesi, kalabalık yönlendirme ve sayım.",
          },
          faqs: [
            {
              question: { en: "If the bus is late, what do we do?", tr: "Otobüs gecikirse ne yaparız?" },
              answer: {
                en: "Inform apron and ops control; open a backup lane to manage passengers.",
                tr: "Apron ve operasyon kontrolü bilgilendir; yolcuyu yönetmek için yedek hat aç.",
              },
            },
            {
              question: { en: "How do we keep headcount during mass arrivals?", tr: "Toplu gelişlerde sayımı nasıl tutarız?" },
              answer: {
                en: "Lead uses a clicker with double-check; align numbers with the departure crew.",
                tr: "Ekip lideri sayaçla çift kontrol yapar; sayıları kalkış ekibiyle eşleştir.",
              },
            },
          ],
        },*/
      ]);

      const SHOW_DEPARTMENT_DESCRIPTIONS = false;

      const MEAL_SHIFTS = Object.freeze([
        {
          shift: { en: "Day shift", tr: "Gündüz vardiyası" },
          meal: { en: "11:30 AM - 2:30 PM", tr: "11:30 - 14:30" },
        },
        {
          shift: { en: "Night shift", tr: "Gece vardiyası" },
          meal: { en: "01:30 AM - 03:30 AM", tr: "01:30 - 03:30" },
        },
      ]);

      const ADMIN_EMAILS = new Set([
        "furkan.ozturk@gmail.com",
      ]);
      
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);
      const RESET_TIMEZONE = "Europe/Istanbul";

      const authCard = document.getElementById("auth-card");
      const dashboard = document.getElementById("dashboard");
      const infoCard = document.getElementById("work-info");
      const appTitleEl = document.getElementById("app-title");
      const appTaglineEl = document.getElementById("app-tagline");
      const languageSelects = Array.from(document.querySelectorAll("[data-language-picker]"));
      const languageLabels = Array.from(document.querySelectorAll(".language-label"));
      const footerNote = document.getElementById("footer-note");
      const authForm = document.getElementById("auth-form");
      const emailInput = document.getElementById("email");
      const fullNameInput = document.getElementById("full-name");
      const passwordInput = document.getElementById("password");
      const passwordToggleButton = document.getElementById("password-visibility");
      const modeButtons = document.querySelectorAll("[data-auth-mode]");
      const fullNameField = document.getElementById("full-name-field");
      const authSubmitButton = document.getElementById("auth-submit");
      const authMessage = document.getElementById("auth-message");
      const emailLabelEl = document.getElementById("email-label");
      const fullNameLabelEl = document.getElementById("full-name-label");
      const passwordLabelEl = document.getElementById("password-label");
      const rosterMessage = document.getElementById("roster-message");
      const groupMessage = document.getElementById("group-message");
      const joinButton = document.getElementById("join-btn");
      const leaveButton = document.getElementById("leave-btn");
      const onBreakList = document.getElementById("on-break");
      const offBreakList = document.getElementById("off-break");
      const mealJoinButton = document.getElementById("meal-join-btn");
      const mealLeaveButton = document.getElementById("meal-leave-btn");
      const onMealBreakList = document.getElementById("on-meal-break");
      const offMealBreakList = document.getElementById("off-meal-break");
      const userEmailEl = document.getElementById("user-email");
      const signOutButton = document.getElementById("sign-out");
      const adminPanel = document.getElementById("admin-panel");
      const adminGroupsContainer = document.getElementById("admin-groups");
      const adminUserEmail = document.getElementById("admin-user-email");
      const adminSignOutButton = document.getElementById("admin-sign-out");
      const roleSelect = document.getElementById("role-select");
      const roleSaveButton = document.getElementById("role-save");
      const roleCurrent = document.getElementById("role-current");
      const roleMessage = document.getElementById("role-message");
      const signedInLabel = document.getElementById("signed-in-label");
      const onBreakHeading = document.getElementById("on-break-heading");
      const workingHeading = document.getElementById("working-heading");
      const onMealHeading = document.getElementById("on-meal-heading");
      const offMealHeading = document.getElementById("off-meal-heading");
      const adminLogsSection = document.getElementById("admin-logs");
      const logTable = document.getElementById("log-table");
      const logsMessage = document.getElementById("logs-message");
      const logGroupSelect = document.getElementById("log-group-select");
      const logExportScope = document.getElementById("log-export-scope");
      const exportLogsButton = document.getElementById("export-logs");
      const resetSelectedLogsButton = document.getElementById("reset-selected-logs");
      const resetAllLogsButton = document.getElementById("reset-all-logs");
      const logCollapseButton = document.getElementById("log-collapse-btn");
      const logExpandButton = document.getElementById("log-expand-btn");
      const departmentList = document.getElementById("department-list");
      const mealShiftsBody = document.getElementById("meal-shifts");
      const infoEyebrow = document.getElementById("info-eyebrow");
      const infoTitle = document.getElementById("info-title");
      const infoFaqToggleButton = document.getElementById("info-faq-toggle");
      const mealShiftTitle = document.getElementById("meal-shift-title");
      const mealShiftHeader = document.getElementById("meal-shift-header");
      const mealWindowHeader = document.getElementById("meal-window-header");
      const logsHeadingTitle = document.getElementById("logs-heading-title");
      const adminStaffLabel = document.getElementById("admin-staff-label");

      let authMode = "signin";
      let currentUser = null;
      let currentGroupId = null;
      let currentProfile = { fullName: "", language: null };
      let pendingIdentity = null;
      let rosterEntries = [];
      let rosterUnsubscribe = null;
      let groupUnsubscribe = null;
      let selfEntry = null;
      let isRosterMutating = false;
      let isRoleUpdating = false;
      let isPasswordVisible = false;
      let isAdmin = false;
      const adminRosterData = new Map();
      const adminRosterUnsubscribes = new Map();
      const minimizedAdminGroups = new Set();
      const ADMIN_LAYOUT_STORAGE_PREFIX = "adminGroupLayout";
      const LOG_LAYOUT_STORAGE_PREFIX = "logGroupLayout";
      const selectedLogGroups = new Set();
      let exportScopeMode = "all";
      let isResettingLogs = false;
      let logRefreshTimer = null;
      const LOG_REFRESH_INTERVAL_MS = 60_000;
      const RESET_CONFIRM_TIMEOUT_MS = 6_000;
      const resetConfirmTimers = new Map();
      let logsCollapsed = false;
      const collapsedLogGroups = new Set();
      const CSV_SEPARATOR = ";";
      const INFO_FAQ_COLLAPSE_STORAGE_KEY = "infoFaqCollapsed";
      let faqsCollapsed = false;

      try {
        faqsCollapsed = localStorage.getItem(INFO_FAQ_COLLAPSE_STORAGE_KEY) === "1";
      } catch {
        /* ignore storage issues */
      }

      function getCopy() {
        return COPY[currentLanguage] || COPY.en;
      }

      function isValidLanguage(lang) {
        return Boolean(lang && COPY[lang]);
      }

      function t(path, replacements = {}) {
        const parts = String(path || "").split(".");
        const langCopy = getCopy();
        const fallbackCopy = COPY.en;
        const resolve = (copy) => parts.reduce((value, key) => value?.[key], copy);
        let template = resolve(langCopy);
        if (template === undefined) {
          template = resolve(fallbackCopy);
        }
        if (typeof template !== "string") return "";
        return template.replace(/\{(\w+)\}/g, (match, key) =>
          Object.prototype.hasOwnProperty.call(replacements, key) ? replacements[key] : match
        );
      }

      function pickLanguageValue(map) {
        if (!map) return "";
        return map[currentLanguage] ?? map.en ?? "";
      }

      function applyLanguage() {
        const copy = getCopy();
        document.documentElement.lang = currentLanguage;
        if (document.body) {
          document.body.dataset.loadingLabel = copy.loading || "";
        }
        languageSelects.forEach((select) => {
          select.innerHTML = "";
          LANGUAGE_OPTIONS.forEach((langOption) => {
            const option = document.createElement("option");
            option.value = langOption.value;
            option.textContent = langOption.label;
            select.appendChild(option);
          });
          select.value = currentLanguage;
          if (copy.languageLabel) {
            select.setAttribute("aria-label", copy.languageLabel);
          }
        });
        languageLabels.forEach((labelEl) => {
          labelEl.textContent = copy.languageLabel;
        });
        if (footerNote) {
          footerNote.textContent = copy.footer?.note ?? COPY.en.footer?.note ?? "";
        }
        if (appTitleEl) appTitleEl.textContent = copy.header.title;
        if (appTaglineEl) appTaglineEl.textContent = copy.header.tagline;
        if (emailLabelEl) emailLabelEl.textContent = copy.auth.emailLabel;
        if (fullNameLabelEl) fullNameLabelEl.textContent = copy.auth.fullNameLabel;
        if (passwordLabelEl) passwordLabelEl.textContent = copy.auth.passwordLabel;
        if (emailInput) emailInput.placeholder = copy.auth.emailPlaceholder;
        if (fullNameInput) fullNameInput.placeholder = copy.auth.fullNamePlaceholder;
        if (passwordInput) passwordInput.placeholder = copy.auth.passwordPlaceholder;
        const authToggle = document.querySelector(".auth-toggle");
        if (authToggle && copy.auth.ariaAuthMode) {
          authToggle.setAttribute("aria-label", copy.auth.ariaAuthMode);
        }
        const roleSelectLabel = document.querySelector('label[for="role-select"]');
        if (roleSelectLabel) {
          roleSelectLabel.textContent = copy.dashboard.roleLabel;
        }
        const srInfoTitle = document.querySelector(".info-section-title.sr-only");
        if (srInfoTitle) {
          srInfoTitle.textContent = copy.info.title;
        }
        const mealTable = document.querySelector(".shift-table");
        if (mealTable && copy.info.mealTitle) {
          mealTable.setAttribute("aria-label", copy.info.mealTitle);
        }
        if (signedInLabel) signedInLabel.textContent = copy.dashboard.signedInAs;
        if (onBreakHeading) onBreakHeading.textContent = copy.lists.onBreak;
        if (workingHeading) workingHeading.textContent = copy.lists.working;
        if (onMealHeading) onMealHeading.textContent = copy.lists.onMealBreak;
        if (offMealHeading) offMealHeading.textContent = copy.lists.offMealBreak;
        if (joinButton) joinButton.textContent = copy.lists.join;
        if (leaveButton) leaveButton.textContent = copy.lists.leave;
        if (mealJoinButton) mealJoinButton.textContent = copy.lists.mealJoin;
        if (mealLeaveButton) mealLeaveButton.textContent = copy.lists.mealLeave;
        if (signOutButton) signOutButton.textContent = copy.dashboard.signOut;
        if (adminSignOutButton) adminSignOutButton.textContent = copy.dashboard.signOut;
        if (roleSaveButton) roleSaveButton.textContent = copy.dashboard.updateRole;
        if (adminStaffLabel) adminStaffLabel.textContent = copy.admin.staffView;
        if (logsHeadingTitle) logsHeadingTitle.textContent = copy.admin.logsHeading;
        if (resetSelectedLogsButton) {
          resetSelectedLogsButton.textContent = copy.admin.resetSelected;
          resetSelectedLogsButton.dataset.defaultLabel = copy.admin.resetSelected;
        }
        if (resetAllLogsButton) {
          resetAllLogsButton.textContent = copy.admin.resetAll;
          resetAllLogsButton.dataset.defaultLabel = copy.admin.resetAll;
        }
        if (exportLogsButton) {
          exportLogsButton.textContent = copy.admin.exportCsv;
        }
        if (logExportScope) {
          const allLabel = logExportScope.querySelector('input[value="all"]')?.nextElementSibling;
          const selectedLabel = logExportScope.querySelector('input[value="selected"]')?.nextElementSibling;
          if (allLabel) allLabel.textContent = copy.admin.exportScopeAll;
          if (selectedLabel) selectedLabel.textContent = copy.admin.exportScopeSelected;
        }
        if (logGroupSelect) logGroupSelect.setAttribute("aria-label", copy.admin.selectGroupsLabel);
        if (infoEyebrow) infoEyebrow.textContent = copy.info.eyebrow;
        if (infoTitle) infoTitle.textContent = copy.info.title;
        if (mealShiftTitle) mealShiftTitle.textContent = copy.info.mealTitle;
        if (mealShiftHeader) mealShiftHeader.textContent = copy.info.shift;
        if (mealWindowHeader) mealWindowHeader.textContent = copy.info.meal;
        syncInfoFaqToggleButton();
        setAuthMode(authMode, { keepMessage: true, keepPasswordVisibility: true });
        populateRoleSelect();
        renderWorkInfo();
        renderLists();
        renderAdminPanel();
        renderLogGroupSelector();
        renderStaffLogs();
        clearResetConfirmation(resetAllLogsButton);
        clearResetConfirmation(resetSelectedLogsButton);
        if (groupMessage && !groupMessage.classList.contains("error")) {
          if (isAdmin) {
            setGroupMessage(t("messages.breakOverview"));
          } else if (currentGroupId && currentUser) {
            setGroupMessage(t("dashboard.groupLabel", { group: groupLabel(currentGroupId) }));
          } else if (currentUser) {
            setGroupMessage(t("dashboard.lookingUpGroup"));
          } else {
            setGroupMessage("");
          }
        }
      }

      async function persistLanguagePreference(user, lang) {
        if (!user || !isValidLanguage(lang)) return;
        try {
          await setDoc(
            doc(db, "userProfiles", user.uid),
            { language: lang, updatedAt: serverTimestamp() },
            { merge: true }
          );
          currentProfile = { ...currentProfile, language: lang };
        } catch (error) {
          console.error("Unable to save language preference", error);
        }
      }

      function setLanguage(lang, { persist = false } = {}) {
        const nextLang = isValidLanguage(lang) ? lang : DEFAULT_LANGUAGE;
        const shouldPersist =
          persist &&
          currentUser &&
          (!isValidLanguage(currentProfile?.language) || currentProfile.language !== nextLang);
        currentLanguage = nextLang;
        document.documentElement.lang = currentLanguage;
        applyLanguage();
        if (shouldPersist) {
          persistLanguagePreference(currentUser, currentLanguage);
        }
      }

      function toggleViews(isSignedIn) {
        const signedIn = Boolean(isSignedIn);
        if (authCard) authCard.classList.toggle("hidden", signedIn);
        if (dashboard) dashboard.classList.toggle("hidden", !signedIn || Boolean(isAdmin));
        syncInfoCardVisibility();
      }

      function syncInfoCardVisibility() {
        if (!infoCard) return;
        const shouldShow = Boolean(isAdmin || (currentUser && currentGroupId));
        infoCard.classList.toggle("hidden", !shouldShow);
      }

      function setAuthMessage(message, isError = false) {
        authMessage.textContent = message;
        authMessage.classList.toggle("error", isError);
      }

      function setRosterMessage(message = "", isError = false) {
        if (!rosterMessage) return;
        rosterMessage.textContent = message;
        rosterMessage.classList.toggle("error", isError);
      }

      function setGroupMessage(message = "", isError = false) {
        if (!groupMessage) return;
        groupMessage.textContent = message;
        groupMessage.classList.toggle("error", isError);
      }

      function setRoleMessage(message = "", isError = false) {
        if (!roleMessage) return;
        roleMessage.textContent = message;
        roleMessage.classList.toggle("error", isError);
      }

      function setLogMessage(message = "", isError = false) {
        if (!logsMessage) return;
        const text = message ?? "";
        logsMessage.textContent = text;
        logsMessage.classList.toggle("error", Boolean(text) && isError);
        logsMessage.classList.toggle("hidden", !text);
      }

      function syncLogCollapseButtons() {
        if (logCollapseButton) {
          logCollapseButton.disabled = logsCollapsed;
        }
        if (logExpandButton) {
          logExpandButton.disabled = !logsCollapsed;
        }
      }

      function setLogsCollapsed(collapsed) {
        logsCollapsed = Boolean(collapsed);
        if (logTable) {
          logTable.classList.toggle("hidden", logsCollapsed);
        }
        syncLogCollapseButtons();
      }

      function syncInfoFaqToggleButton() {
        if (!infoFaqToggleButton) return;
        const copy = getCopy();
        infoFaqToggleButton.textContent = faqsCollapsed ? copy.info.expand : copy.info.collapse;
        infoFaqToggleButton.setAttribute("aria-pressed", String(faqsCollapsed));
        infoFaqToggleButton.setAttribute("aria-expanded", String(!faqsCollapsed));
        const label = faqsCollapsed ? copy.info.expandFaqsLabel : copy.info.collapseFaqsLabel;
        if (label) {
          infoFaqToggleButton.setAttribute("aria-label", label);
          infoFaqToggleButton.title = label;
        }
      }

      function saveFaqCollapseState(collapsed) {
        try {
          localStorage.setItem(INFO_FAQ_COLLAPSE_STORAGE_KEY, collapsed ? "1" : "0");
        } catch {
          /* ignore storage issues */
        }
      }

      function setFaqsCollapsed(collapsed, { persist = true } = {}) {
        faqsCollapsed = Boolean(collapsed);
        if (infoCard) {
          infoCard.classList.toggle("faqs-collapsed", faqsCollapsed);
        }
        if (persist) {
          saveFaqCollapseState(faqsCollapsed);
        }
        syncInfoFaqToggleButton();
      }

      function setLogGroupCollapsed(groupId, collapsed) {
        if (!isValidGroupId(groupId)) return;
        if (collapsed) {
          collapsedLogGroups.add(groupId);
        } else {
          collapsedLogGroups.delete(groupId);
        }
        saveLogLayout();
        renderStaffLogs();
      }

      function hasAnyLogData(groupIds = Object.keys(GROUPS)) {
        return groupIds.some((groupId) => {
          const roster = adminRosterData.get(groupId) ?? [];
          return Array.isArray(roster) && roster.length > 0;
        });
      }

      function renderDepartmentDetails() {
        if (!departmentList) return;
        const fragment = document.createDocumentFragment();
        DEPARTMENT_DETAILS.forEach((dept) => {
          const item = document.createElement("li");
          item.className = "info-item";

          const header = document.createElement("div");
          header.className = "info-item-header";

          const title = document.createElement("p");
          title.className = "info-item-title";
          title.textContent = pickLanguageValue(dept.name);
          header.appendChild(title);

          item.appendChild(header);

          if (SHOW_DEPARTMENT_DESCRIPTIONS && dept.description) {
            const desc = document.createElement("p");
            desc.className = "info-item-desc";
            desc.textContent = pickLanguageValue(dept.description);
            item.appendChild(desc);
          }

          if (Array.isArray(dept.faqs) && dept.faqs.length) {
            const faqList = document.createElement("ul");
            faqList.className = "dept-faq";
            dept.faqs.forEach((faq) => {
              const faqItem = document.createElement("li");
              faqItem.className = "faq-row";

              const question = document.createElement("p");
              question.className = "faq-question";
              question.textContent = pickLanguageValue(faq.question);
              faqItem.appendChild(question);

              const answer = document.createElement("p");
              answer.className = "faq-answer";
              answer.textContent = pickLanguageValue(faq.answer);
              faqItem.appendChild(answer);

              faqList.appendChild(faqItem);
            });
            item.appendChild(faqList);
          }

          fragment.appendChild(item);
        });
        departmentList.replaceChildren(fragment);
      }

      function renderMealShifts() {
        if (!mealShiftsBody) return;
        const fragment = document.createDocumentFragment();
        MEAL_SHIFTS.forEach((slot) => {
          const row = document.createElement("tr");

          const shiftCell = document.createElement("td");
          shiftCell.textContent = pickLanguageValue(slot.shift);
          row.appendChild(shiftCell);

          const mealCell = document.createElement("td");
          mealCell.textContent = pickLanguageValue(slot.meal);
          row.appendChild(mealCell);

          fragment.appendChild(row);
        });
        mealShiftsBody.replaceChildren(fragment);
      }

      function renderWorkInfo() {
        renderDepartmentDetails();
        renderMealShifts();
      }

      function clearResetConfirmation(button) {
        if (!button) return;
        const timer = resetConfirmTimers.get(button);
        if (timer) {
          clearTimeout(timer);
          resetConfirmTimers.delete(button);
        }
        button.classList.remove("confirm");
        if (button.dataset.defaultLabel) {
          button.textContent = button.dataset.defaultLabel;
        }
        button.dataset.confirm = "false";
      }

      function requestResetConfirmation(button, confirmText) {
        if (!button) return false;
        const otherButton =
          button === resetAllLogsButton ? resetSelectedLogsButton : resetAllLogsButton;
        clearResetConfirmation(otherButton);
        if (button.dataset.confirm === "true") {
          clearResetConfirmation(button);
          return true;
        }
        button.dataset.confirm = "true";
        button.dataset.defaultLabel = button.dataset.defaultLabel || button.textContent;
        button.textContent = confirmText;
        button.classList.add("confirm");
        const timer = setTimeout(() => clearResetConfirmation(button), RESET_CONFIRM_TIMEOUT_MS);
        resetConfirmTimers.set(button, timer);
        return false;
      }

      function isAdminAccount(user) {
        const email = typeof user === "string" ? user : user?.email;
        return Boolean(email && ADMIN_EMAILS.has(String(email).toLowerCase()));
      }

      function setAdminMode(enabled) {
        isAdmin = Boolean(enabled);
        if (adminPanel) {
          adminPanel.classList.toggle("hidden", !isAdmin);
        }
        if (adminLogsSection) {
          adminLogsSection.classList.toggle("hidden", !isAdmin);
        }
        if (isAdmin && adminUserEmail && currentUser) {
          adminUserEmail.textContent = currentUser.email;
        }
        if (!isAdmin) {
          stopAdminRosterWatchers();
          stopLogTicker();
          if (adminGroupsContainer) {
            adminGroupsContainer.innerHTML = "";
          }
          if (logTable) {
            logTable.innerHTML = "";
          }
          selectedLogGroups.clear();
          collapsedLogGroups.clear();
          renderLogGroupSelector();
          setLogMessage("");
          setLogsCollapsed(false);
        } else {
          loadAdminLayout();
          loadLogLayout();
          renderAdminPanel();
          renderLogGroupSelector();
          renderStaffLogs();
          setLogMessage("");
          startLogTicker();
          setLogsCollapsed(false);
        }
        syncInfoCardVisibility();
        syncLogResetButtons();
      }

      function setPasswordVisibility(visible) {
        if (!passwordInput) return;
        isPasswordVisible = Boolean(visible);
        passwordInput.type = isPasswordVisible ? "text" : "password";
        if (passwordToggleButton) {
          const copy = getCopy();
          passwordToggleButton.textContent = isPasswordVisible ? copy.auth.hide : copy.auth.show;
          passwordToggleButton.setAttribute("aria-pressed", String(isPasswordVisible));
        }
      }

      function setAuthMode(mode, { keepMessage = false, keepPasswordVisibility = false } = {}) {
        authMode = mode === "register" ? "register" : "signin";
        const needsFullName = authMode === "register";
        const copy = getCopy();
        modeButtons.forEach((button) => {
          const isActive = button.dataset.authMode === authMode;
          button.classList.toggle("active", isActive);
          button.setAttribute("aria-pressed", String(isActive));
          const label =
            button.dataset.authMode === "register" ? copy.auth.tabRegister : copy.auth.tabSignIn;
          button.textContent = label;
        });
        fullNameField.classList.toggle("hidden", !needsFullName);
        fullNameInput.required = needsFullName;
        authSubmitButton.textContent = needsFullName
          ? copy.auth.submitRegister
          : copy.auth.submitSignIn;
        if (needsFullName) {
          attemptFullNamePrefill();
        }
        if (!keepMessage) {
          setAuthMessage("");
        }
        const nextVisibility = keepPasswordVisibility ? isPasswordVisible : false;
        setPasswordVisibility(nextVisibility);
      }

      function isValidGroupId(groupId) {
        return Boolean(groupId && GROUPS[groupId]);
      }

      function adminLayoutStorageKey(user = currentUser) {
        const email = user?.email ? String(user.email).toLowerCase() : "default";
        return `${ADMIN_LAYOUT_STORAGE_PREFIX}:${email}`;
      }

      function saveAdminLayout(user = currentUser) {
        try {
          localStorage.setItem(adminLayoutStorageKey(user), JSON.stringify([...minimizedAdminGroups]));
        } catch {
          /* ignore storage issues */
        }
      }

      function loadAdminLayout(user = currentUser) {
        try {
          const stored = localStorage.getItem(adminLayoutStorageKey(user));
          if (!stored) return;
          const parsed = JSON.parse(stored);
          if (!Array.isArray(parsed)) return;
          minimizedAdminGroups.clear();
          parsed.forEach((groupId) => {
            if (isValidGroupId(groupId)) {
              minimizedAdminGroups.add(groupId);
            }
          });
        } catch {
          /* ignore storage issues */
        }
      }

      function logLayoutStorageKey(user = currentUser) {
        const email = user?.email ? String(user.email).toLowerCase() : "default";
        return `${LOG_LAYOUT_STORAGE_PREFIX}:${email}`;
      }

      function saveLogLayout(user = currentUser) {
        try {
          localStorage.setItem(logLayoutStorageKey(user), JSON.stringify([...collapsedLogGroups]));
        } catch {
          /* ignore storage issues */
        }
      }

      function loadLogLayout(user = currentUser) {
        try {
          const stored = localStorage.getItem(logLayoutStorageKey(user));
          if (!stored) return;
          const parsed = JSON.parse(stored);
          if (!Array.isArray(parsed)) return;
          collapsedLogGroups.clear();
          parsed.forEach((groupId) => {
            if (isValidGroupId(groupId)) {
              collapsedLogGroups.add(groupId);
            }
          });
        } catch {
          /* ignore storage issues */
        }
      }

      function roleLabel(roleId) {
        const match = ROLE_OPTIONS.find((role) => role.id === roleId);
        return match ? pickLanguageValue(match.labels) : "";
      }

      function sanitizeRoleId(roleId) {
        return ROLE_OPTIONS.some((role) => role.id === roleId) ? roleId : "";
      }

      function populateRoleSelect() {
        if (!roleSelect) return;
        const current = roleSelect.value;
        roleSelect.innerHTML = `<option value="">${t("dashboard.rolePlaceholder")}</option>`;
        ROLE_OPTIONS.forEach((role) => {
          const option = document.createElement("option");
          option.value = role.id;
          option.textContent = roleLabel(role.id);
          roleSelect.appendChild(option);
        });
        if (current && sanitizeRoleId(current)) {
          roleSelect.value = current;
        }
      }

      function setRoleControlsDisabled(disabled) {
        if (roleSelect) roleSelect.disabled = disabled;
        if (roleSaveButton) roleSaveButton.disabled = disabled;
      }

      function syncRoleUI(entry = selfEntry) {
        const roleId = sanitizeRoleId(entry?.role);
        if (roleSelect) {
          roleSelect.value = roleId;
        }
        if (roleCurrent) {
          const label = roleLabel(roleId);
          roleCurrent.textContent = label || t("dashboard.noRoleSelected");
        }
        setRoleControlsDisabled(!currentUser || !currentGroupId || isRoleUpdating);
      }

      function groupLabel(groupId) {
        return GROUPS[groupId] ?? groupId ?? "";
      }

      function sanitizeFullName(value) {
        return value ? value.replace(/\s+/g, " ").trim() : "";
      }

      function rememberFullName(email, fullName) {
        if (!email || !fullName) return;
        try {
          localStorage.setItem(`fullName:${email}`, fullName);
        } catch {
          /* ignore storage issues */
        }
      }

      function recallFullName(email) {
        if (!email) return "";
        try {
          return localStorage.getItem(`fullName:${email}`) ?? "";
        } catch {
          return "";
        }
      }

      function getCurrentFullName() {
        return (
          sanitizeFullName(currentProfile?.fullName) ||
          sanitizeFullName(pendingIdentity?.fullName) ||
          ""
        );
      }

      async function saveProfileFullName(user, fullName) {
        if (!user || !fullName) return;
        const profileRef = doc(db, "userProfiles", user.uid);
        try {
          await setDoc(
            profileRef,
            {
              fullName,
              email: user.email,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          currentProfile = { fullName };
        } catch (error) {
          console.error("Unable to save profile name", error);
          throw error;
        }
      }

      async function fetchProfile(user) {
        if (!user) return null;
        try {
          const snapshot = await getDoc(doc(db, "userProfiles", user.uid));
          if (snapshot.exists()) {
            return snapshot.data();
          }
        } catch (error) {
          console.error("Unable to load profile", error);
        }
        return null;
      }

      function toDate(value) {
        if (!value) return null;
        if (typeof value.toDate === "function") {
          try {
            return value.toDate();
          } catch {
            return null;
          }
        }
        const date = new Date(value);
        return Number.isNaN(date.getTime()) ? null : date;
      }

      function getTimestampValue(value) {
        const date = toDate(value);
        return date ? date.getTime() : Number.MAX_SAFE_INTEGER;
      }

      function formatTime(value) {
        const date = toDate(value);
        if (!date) return "--:--";
        const locale = currentLanguage === "tr" ? "tr-TR" : "en-US";
        const use24Hour = currentLanguage === "tr";
        try {
          return new Intl.DateTimeFormat(locale, {
            hour: "numeric",
            minute: "2-digit",
            hour12: !use24Hour,
          }).format(date);
        } catch {
          return "--:--";
        }
      }

      function formatDuration(ms) {
        const labels = getCopy().time || COPY.en.time;
        const safeMs = Number.isFinite(ms) ? ms : 0;
        const minuteLabel = labels.minute || "m";
        const hourLabel = labels.hour || "h";
        if (safeMs <= 0) return `0${minuteLabel}`;
        const totalMinutes = Math.round(safeMs / 60000);
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        if (hours && minutes) return `${hours}${hourLabel} ${minutes}${minuteLabel}`;
        if (hours) return `${hours}${hourLabel}`;
        return `${minutes}${minuteLabel}`;
      }

      function formatCsvValue(value, separator = CSV_SEPARATOR) {
        if (value === null || value === undefined) return "";
        const text = String(value);
        const needsEscaping = new RegExp(`[\"\\n${separator}]`).test(text);
        if (needsEscaping) {
          return `"${text.replace(/"/g, '""')}"`;
        }
        return text;
      }

      function formatRelativeTime(value) {
        const date = toDate(value);
        if (!date) return "—";
        const diffMs = Date.now() - date.getTime();
        const labels = getCopy().time || COPY.en.time;
        const direction = diffMs >= 0 ? labels.ago : labels.fromNow;
        const absMs = Math.abs(diffMs);
        const minute = 60_000;
        const hour = 3_600_000;
        const day = 86_400_000;
        if (absMs < minute) {
          const base = labels.lessThanMinute || "<1m";
          return `${base} ${direction}`.trim();
        }
        if (absMs < hour) return `${Math.round(absMs / minute)}${labels.minute} ${direction}`;
        if (absMs < day) return `${Math.round(absMs / hour)}${labels.hour} ${direction}`;
        return `${Math.round(absMs / day)}${labels.day} ${direction}`;
      }

      function normalizeBreakStats(entry) {
        const breakCount = Number.isFinite(entry?.breakCount) ? entry.breakCount : 0;
        const breakDurationMs = Number.isFinite(entry?.breakDurationMs)
          ? Math.max(0, entry.breakDurationMs)
          : 0;
        const mealBreakDurationMs = Number.isFinite(entry?.mealBreakDurationMs)
          ? Math.max(0, entry.mealBreakDurationMs)
          : 0;
        const logDateKey = typeof entry?.logDateKey === "string" ? entry.logDateKey : "";
        return { breakCount, breakDurationMs, mealBreakDurationMs, logDateKey };
      }

      function getBreakStatsForToday(entry) {
        const today = currentResetDateKey();
        const { breakCount, breakDurationMs, mealBreakDurationMs, logDateKey } =
          normalizeBreakStats(entry);
        if (logDateKey !== today) {
          return {
            breakCount: 0,
            breakDurationMs: 0,
            mealBreakDurationMs: 0,
            logDateKey: today,
            reset: true,
          };
        }
        return {
          breakCount,
          breakDurationMs,
          mealBreakDurationMs,
          logDateKey: today,
          reset: false,
        };
      }

      function elapsedSince(value) {
        const date = toDate(value);
        if (!date) return 0;
        return Math.max(0, Date.now() - date.getTime());
      }

      function currentMealBreakElapsed(entry) {
        if (!isOnMealBreakToday(entry)) return 0;
        return elapsedSince(entry.mealJoinedAt);
      }

      function currentBreakElapsed(entry) {
        if (!entry?.isOnBreak || !isOnBreakToday(entry)) return 0;
        return elapsedSince(entry.joinedAt);
      }

      function currentResetDateKey() {
        try {
          const formatter = new Intl.DateTimeFormat("en-CA", {
            timeZone: RESET_TIMEZONE,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
          });
          return formatter.format(new Date());
        } catch {
          const today = new Date();
          const month = String(today.getMonth() + 1).padStart(2, "0");
          const day = String(today.getDate()).padStart(2, "0");
          return `${today.getFullYear()}-${month}-${day}`;
        }
      }

      function dateKeyFor(value) {
        const date = toDate(value);
        if (!date) return "";
        try {
          const formatter = new Intl.DateTimeFormat("en-CA", {
            timeZone: RESET_TIMEZONE,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
          });
          return formatter.format(date);
        } catch {
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          return `${date.getFullYear()}-${month}-${day}`;
        }
      }

      function isOnBreakToday(entry) {
        const onBreak = entry?.isOnBreak;
        if (!entry || !onBreak || !entry.joinedAt) return false;
        return dateKeyFor(entry.joinedAt) === currentResetDateKey();
      }

      function isOnMealBreakToday(entry) {
        const onMealBreak = entry?.isOnMealBreak;
        if (!entry || !onMealBreak || !entry.mealJoinedAt) return false;
        return dateKeyFor(entry.mealJoinedAt) === currentResetDateKey();
      }

      function updateActionButtons() {
        if (!currentUser || !currentGroupId) {
          if (joinButton) joinButton.disabled = true;
          if (leaveButton) leaveButton.disabled = true;
          if (mealJoinButton) mealJoinButton.disabled = true;
          if (mealLeaveButton) mealLeaveButton.disabled = true;
          return;
        }
        const entry =
          rosterEntries.find((record) => record.id === currentUser.uid) ?? selfEntry;
        const hasRole = Boolean(sanitizeRoleId(entry?.role));
        const isOnBreak = isOnBreakToday(entry);
        const isOnMealBreak = isOnMealBreakToday(entry);
        const disableBreakJoin = isRosterMutating || isOnBreak || isOnMealBreak || !hasRole;
        const disableMealJoin = isRosterMutating || isOnMealBreak || isOnBreak || !hasRole;
        if (joinButton) joinButton.disabled = disableBreakJoin;
        if (leaveButton) leaveButton.disabled = isRosterMutating || !isOnBreak;
        if (mealJoinButton) mealJoinButton.disabled = disableMealJoin;
        if (mealLeaveButton) mealLeaveButton.disabled = isRosterMutating || !isOnMealBreak;
      }

      function createListItem(entry, { showJoinedAt = false, joinedAtKey = "joinedAt" } = {}) {
        const li = document.createElement("li");

        const person = document.createElement("span");
        person.className = "person";

        const nameSpan = document.createElement("span");
        nameSpan.className = "person-name";
        nameSpan.textContent = entry.fullName ?? entry.email ?? t("persons.unknown");
        person.appendChild(nameSpan);

        const roleText = roleLabel(entry.role);
        const roleSpan = document.createElement("span");
        roleSpan.className = "person-role";
        roleSpan.textContent = roleText || t("persons.roleNotSet");
        person.appendChild(roleSpan);

        li.appendChild(person);

        const joinedValue = joinedAtKey ? entry?.[joinedAtKey] : null;
        if (showJoinedAt && joinedValue) {
          const timeSpan = document.createElement("span");
          timeSpan.className = "time-badge";
          timeSpan.textContent = formatTime(joinedValue);
          li.appendChild(timeSpan);
        }

        return li;
      }

      function populateList(target, entries, emptyText, options = {}) {
        if (!entries.length) {
          target.innerHTML = `<li class="empty">${emptyText}</li>`;
          return;
        }
        const fragment = document.createDocumentFragment();
        entries.forEach((entry) => {
          fragment.appendChild(createListItem(entry, options));
        });
        target.replaceChildren(fragment);
      }

      function normalizeRosterDocument(docSnap) {
        const data = docSnap.data();
        const stats = getBreakStatsForToday(data);
        return {
          id: docSnap.id,
          ...data,
          role: sanitizeRoleId(data.role),
          breakCount: stats.breakCount,
          breakDurationMs: stats.breakDurationMs,
          mealBreakDurationMs: stats.mealBreakDurationMs,
          lastBreakAt: data.lastBreakAt ?? null,
          logDateKey: stats.logDateKey,
        };
      }

      function renderLists() {
        const copy = getCopy();
        if (!currentUser) {
          onBreakList.innerHTML = `<li class="empty">${copy.lists.signInBreak}</li>`;
          offBreakList.innerHTML = `<li class="empty">${copy.lists.signInBreak}</li>`;
          onMealBreakList.innerHTML = `<li class="empty">${copy.lists.signInMeal}</li>`;
          offMealBreakList.innerHTML = `<li class="empty">${copy.lists.signInMeal}</li>`;
          updateActionButtons();
          syncRoleUI();
          return;
        }

        if (!currentGroupId) {
          const awaiting = copy.lists.awaitingGroup;
          onBreakList.innerHTML = `<li class="empty">${awaiting}</li>`;
          offBreakList.innerHTML = `<li class="empty">${awaiting}</li>`;
          onMealBreakList.innerHTML = `<li class="empty">${awaiting}</li>`;
          offMealBreakList.innerHTML = `<li class="empty">${awaiting}</li>`;
          updateActionButtons();
          syncRoleUI();
          return;
        }

        const onBreakEntries = rosterEntries.filter((entry) => isOnBreakToday(entry));
        const workingEntries = rosterEntries.filter((entry) => !isOnBreakToday(entry));
        const onMealBreakEntries = rosterEntries.filter((entry) => isOnMealBreakToday(entry));
        const offMealBreakEntries = rosterEntries.filter((entry) => !isOnMealBreakToday(entry));

        const onBreakSorted = [...onBreakEntries].sort(
          (a, b) => getTimestampValue(a.joinedAt) - getTimestampValue(b.joinedAt)
        );
        const workingSorted = [...workingEntries].sort((a, b) =>
          (a.email ?? "").localeCompare(b.email ?? "", undefined, { sensitivity: "base" })
        );
        const onMealBreakSorted = [...onMealBreakEntries].sort(
          (a, b) => getTimestampValue(a.mealJoinedAt) - getTimestampValue(b.mealJoinedAt)
        );
        const offMealBreakSorted = [...offMealBreakEntries].sort((a, b) =>
          (a.email ?? "").localeCompare(b.email ?? "", undefined, { sensitivity: "base" })
        );
        const hasRosterEntries = rosterEntries.length > 0;
        const emptyFallback = copy.lists.noAssignments;
        const onBreakEmptyText = hasRosterEntries ? copy.lists.nobodyOnBreak : emptyFallback;
        const workingEmptyText = hasRosterEntries ? copy.lists.nobodyWorking : emptyFallback;
        const onMealEmptyText = hasRosterEntries ? copy.lists.nobodyMeal : emptyFallback;
        const offMealEmptyText = hasRosterEntries ? copy.lists.everyoneMeal : emptyFallback;

        populateList(onBreakList, onBreakSorted, onBreakEmptyText, {
          showJoinedAt: true,
        });
        populateList(offBreakList, workingSorted, workingEmptyText);
        populateList(onMealBreakList, onMealBreakSorted, onMealEmptyText, {
          showJoinedAt: true,
          joinedAtKey: "mealJoinedAt",
        });
        populateList(offMealBreakList, offMealBreakSorted, offMealEmptyText);
        updateActionButtons();
        syncRoleUI();
      }

      function renderAdminPanel() {
        if (!adminGroupsContainer) return;
        const copy = getCopy();
        if (!isAdmin) {
          adminGroupsContainer.innerHTML = "";
          adminGroupsContainer.classList.remove("focus-mode");
          return;
        }

        const groupIds = Object.keys(GROUPS);
        if (!groupIds.length) {
          adminGroupsContainer.innerHTML = `<p class="muted">${copy.admin.noGroups}</p>`;
          adminGroupsContainer.classList.remove("focus-mode");
          return;
        }

        if (minimizedAdminGroups.size >= groupIds.length) {
          minimizedAdminGroups.delete(groupIds[0]);
        }

        const expandedGroupIds = groupIds.filter((id) => !minimizedAdminGroups.has(id));
        const minimizedGroupIds = groupIds.filter((id) => minimizedAdminGroups.has(id));
        const focusMode = expandedGroupIds.length === 1 && groupIds.length > 1;
        adminGroupsContainer.classList.toggle("focus-mode", focusMode);
        const fragment = document.createDocumentFragment();
        const selectedGroupId = focusMode ? expandedGroupIds[0] : null;
        const row = document.createElement("div");
        row.className = "group-chip-row";

        const showAllButton = document.createElement("button");
        showAllButton.type = "button";
        showAllButton.className = `ghost group-chip${minimizedAdminGroups.size === 0 ? " active" : ""}`;
        showAllButton.textContent = copy.admin.showAll || copy.admin.exportScopeAll;
        showAllButton.setAttribute("aria-pressed", String(minimizedAdminGroups.size === 0));
        showAllButton.addEventListener("click", () => {
          if (minimizedAdminGroups.size === 0) return;
          minimizedAdminGroups.clear();
          renderAdminPanel();
        });
        row.appendChild(showAllButton);

        groupIds.forEach((groupId) => {
          const chip = document.createElement("button");
          chip.type = "button";
          chip.className = `ghost group-chip${groupId === selectedGroupId ? " active" : ""}`;
          chip.textContent = t("admin.groupLabel", { group: groupLabel(groupId) });
          chip.setAttribute("aria-pressed", String(groupId === selectedGroupId));
          chip.addEventListener("click", () => {
            if (focusMode && groupId === selectedGroupId) return;
            minimizedAdminGroups.clear();
            groupIds.forEach((id) => {
              if (id !== groupId) minimizedAdminGroups.add(id);
            });
            renderAdminPanel();
          });
          row.appendChild(chip);
        });

        fragment.appendChild(row);

        let orderedGroupIds = [...expandedGroupIds, ...minimizedGroupIds];
        if (focusMode) {
          orderedGroupIds = [selectedGroupId];
        }

        orderedGroupIds.forEach((groupId) => {
          const roster = adminRosterData.get(groupId) ?? [];
          const onEntries = roster.filter((entry) => isOnBreakToday(entry));
          const offEntries = roster.filter((entry) => !isOnBreakToday(entry));
          const onMealEntries = roster.filter((entry) => isOnMealBreakToday(entry));
          const offMealEntries = roster.filter((entry) => !isOnMealBreakToday(entry));
          const hasRosterEntries = roster.length > 0;
          const emptyText = copy.admin.noUsers;
          const onBreakEmptyText = hasRosterEntries ? copy.lists.nobodyOnBreak : emptyText;
          const workingEmptyText = hasRosterEntries ? copy.lists.nobodyWorking : emptyText;
          const onMealEmptyText = hasRosterEntries ? copy.lists.nobodyMeal : emptyText;
          const offMealEmptyText = hasRosterEntries ? copy.lists.everyoneMeal : emptyText;
          const isMinimized = minimizedAdminGroups.has(groupId);

          const card = document.createElement("div");
          card.className = `admin-group-card${isMinimized ? " minimized" : ""}`;

          const header = document.createElement("div");
          header.className = "admin-group-header";

          const title = document.createElement("h3");
          title.textContent = t("admin.groupLabel", { group: groupLabel(groupId) });
          header.appendChild(title);

          const toggleButton = document.createElement("button");
          toggleButton.type = "button";
          toggleButton.className = "ghost admin-toggle";
          toggleButton.textContent = isMinimized ? copy.admin.expand : copy.admin.collapse;
          toggleButton.setAttribute("aria-pressed", String(isMinimized));
          toggleButton.setAttribute("aria-expanded", String(!isMinimized));
          const expandedCount = groupIds.length - minimizedAdminGroups.size;
          toggleButton.disabled = !isMinimized && expandedCount <= 1;
          toggleButton.addEventListener("click", () => {
            const currentlyMinimized = minimizedAdminGroups.has(groupId);
            const expandedNow = groupIds.length - minimizedAdminGroups.size;
            if (!currentlyMinimized && expandedNow <= 1) {
              return;
            }
            if (currentlyMinimized) {
              minimizedAdminGroups.delete(groupId);
            } else {
              minimizedAdminGroups.add(groupId);
            }
            renderAdminPanel();
          });
          header.appendChild(toggleButton);
          card.appendChild(header);

          const body = document.createElement("div");
          body.className = "admin-group-body";

          const breakColumn = document.createElement("div");
          breakColumn.className = "admin-group-column";

          const onLabel = document.createElement("p");
          onLabel.className = "eyebrow";
          onLabel.textContent = copy.lists.onBreak;
          breakColumn.appendChild(onLabel);

          const onList = document.createElement("ul");
          onList.className = "status-list";
          const onSorted = [...onEntries].sort(
            (a, b) => getTimestampValue(a.joinedAt) - getTimestampValue(b.joinedAt)
          );
          populateList(onList, onSorted, onBreakEmptyText, { showJoinedAt: true });
          breakColumn.appendChild(onList);

          const divider = document.createElement("div");
          divider.className = "admin-group-divider";
          breakColumn.appendChild(divider);

          const offLabel = document.createElement("p");
          offLabel.className = "eyebrow";
          offLabel.textContent = copy.lists.working;
          breakColumn.appendChild(offLabel);

          const offList = document.createElement("ul");
          offList.className = "status-list";
          const offSorted = [...offEntries].sort((a, b) =>
            (a.email ?? "").localeCompare(b.email ?? "", undefined, { sensitivity: "base" })
          );
          populateList(offList, offSorted, workingEmptyText);
          breakColumn.appendChild(offList);

          const stackedDivider = document.createElement("div");
          stackedDivider.className = "admin-group-divider admin-group-divider-stack";

          const mealColumn = document.createElement("div");
          mealColumn.className = "admin-group-column";

          const onMealLabel = document.createElement("p");
          onMealLabel.className = "eyebrow";
          onMealLabel.textContent = copy.lists.onMealBreak;
          mealColumn.appendChild(onMealLabel);

          const onMealList = document.createElement("ul");
          onMealList.className = "status-list";
          const onMealSorted = [...onMealEntries].sort(
            (a, b) => getTimestampValue(a.mealJoinedAt) - getTimestampValue(b.mealJoinedAt)
          );
          populateList(onMealList, onMealSorted, onMealEmptyText, {
            showJoinedAt: true,
            joinedAtKey: "mealJoinedAt",
          });
          mealColumn.appendChild(onMealList);

          const dividerMealOff = document.createElement("div");
          dividerMealOff.className = "admin-group-divider";
          mealColumn.appendChild(dividerMealOff);

          const offMealLabel = document.createElement("p");
          offMealLabel.className = "eyebrow";
          offMealLabel.textContent = copy.lists.offMealBreak;
          mealColumn.appendChild(offMealLabel);

          const offMealList = document.createElement("ul");
          offMealList.className = "status-list";
          const offMealSorted = [...offMealEntries].sort((a, b) =>
            (a.email ?? "").localeCompare(b.email ?? "", undefined, { sensitivity: "base" })
          );
          populateList(offMealList, offMealSorted, offMealEmptyText);
          mealColumn.appendChild(offMealList);

          body.appendChild(breakColumn);
          body.appendChild(stackedDivider);
          body.appendChild(mealColumn);
          card.appendChild(body);
          fragment.appendChild(card);
        });

        adminGroupsContainer.replaceChildren(fragment);
        saveAdminLayout();
        renderStaffLogs();
      }

      function syncLogResetButtons() {
        if (resetSelectedLogsButton) {
          const disabled = !isAdmin || isResettingLogs || selectedLogGroups.size === 0;
          resetSelectedLogsButton.disabled = disabled;
          if (disabled) {
            clearResetConfirmation(resetSelectedLogsButton);
          }
        }
        if (resetAllLogsButton) {
          const disabled = !isAdmin || isResettingLogs;
          resetAllLogsButton.disabled = disabled;
          if (disabled) {
            clearResetConfirmation(resetAllLogsButton);
          }
        }
        if (exportLogsButton) {
          const targetGroups =
            exportScopeMode === "selected" && selectedLogGroups.size > 0
              ? [...selectedLogGroups].filter((groupId) => isValidGroupId(groupId))
              : Object.keys(GROUPS);
          const missingSelection = exportScopeMode === "selected" && selectedLogGroups.size === 0;
          const disabled = !isAdmin || missingSelection || !hasAnyLogData(targetGroups);
          exportLogsButton.disabled = disabled;
        }
      }

      function renderLogGroupSelector() {
        if (!logGroupSelect) return;
        const copy = getCopy();
        const groupIds = Object.keys(GROUPS);
        if (!groupIds.length) {
          logGroupSelect.innerHTML = `<p class="muted">${copy.admin.noGroups}</p>`;
          syncLogResetButtons();
          return;
        }
        logGroupSelect.setAttribute("aria-label", copy.admin.selectGroupsLabel);
        [...selectedLogGroups].forEach((groupId) => {
          if (!isValidGroupId(groupId)) {
            selectedLogGroups.delete(groupId);
          }
        });
        const fragment = document.createDocumentFragment();
        groupIds.forEach((groupId) => {
          const labelEl = document.createElement("label");
          labelEl.className = "log-option";

          const input = document.createElement("input");
          input.type = "checkbox";
          input.value = groupId;
          input.checked = selectedLogGroups.has(groupId);
          input.addEventListener("change", () => {
            if (input.checked) {
              selectedLogGroups.add(groupId);
            } else {
              selectedLogGroups.delete(groupId);
            }
            syncLogResetButtons();
          });
          labelEl.appendChild(input);

          const text = document.createElement("span");
          text.textContent = t("admin.groupLabel", { group: groupLabel(groupId) });
          labelEl.appendChild(text);
          fragment.appendChild(labelEl);
        });
        logGroupSelect.replaceChildren(fragment);
        syncLogResetButtons();
      }

      function setupExportScopeControls() {
        if (!logExportScope) return;
        const inputs = logExportScope.querySelectorAll('input[name="export-scope"]');
        inputs.forEach((input) => {
          input.addEventListener("change", () => {
            exportScopeMode = input.value === "selected" ? "selected" : "all";
            syncLogResetButtons();
          });
        });
      }

      function buildLogExportRows(groupIds) {
        const rows = [];
        groupIds.forEach((groupId) => {
          const roster = adminRosterData.get(groupId) ?? [];
          roster.forEach((entry) => {
            const stats = getBreakStatsForToday(entry);
            rows.push([
              entry.fullName ?? entry.email ?? "",
              roleLabel(entry.role) || t("persons.roleNotSet"),
              stats.breakCount ?? 0,
              formatDuration(stats.breakDurationMs + currentBreakElapsed(entry)),
              formatDuration(stats.mealBreakDurationMs + currentMealBreakElapsed(entry)),
              formatRelativeTime(entry.lastBreakAt ?? null),
            ]);
          });
        });
        return rows;
      }

      function downloadCsv(content, filename) {
        if (!content) return;
        try {
          const blob = new Blob([content], { type: "text/csv;charset=utf-8;" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          link.remove();
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error("CSV download failed", error);
          throw error;
        }
      }

      function exportLogsToCsv() {
        if (!isAdmin) return;
        const targetGroups =
          exportScopeMode === "selected" && selectedLogGroups.size > 0
            ? [...selectedLogGroups].filter((groupId) => isValidGroupId(groupId))
            : Object.keys(GROUPS);
        if (!targetGroups.length) {
          setLogMessage(t("admin.noGroups"), true);
          return;
        }
        if (!hasAnyLogData(targetGroups)) {
          setLogMessage(t("messages.exportNoData"), true);
          return;
        }
        const headers = [
          t("logTable.worker"),
          t("logTable.role"),
          t("logTable.breaks"),
          t("logTable.timeOnBreak"),
          t("logTable.timeOnMeal"),
          t("logTable.lastBreak"),
        ];
        const rows = buildLogExportRows(targetGroups);
        if (!rows.length) {
          setLogMessage(t("messages.exportNoData"), true);
          return;
        }
        const csvLines = [headers, ...rows].map((row) =>
          row.map((cell) => formatCsvValue(cell)).join(CSV_SEPARATOR)
        );
        try {
          const csvContent = `\ufeff${csvLines.join("\r\n")}`;
          downloadCsv(csvContent, `break-logs-${currentResetDateKey()}.csv`);
          setLogMessage(t("messages.exportReady"));
        } catch (error) {
          console.error("Log export failed", error);
          setLogMessage(t("messages.exportFailed"), true);
        }
      }

      function renderStaffLogs() {
        if (!logTable) return;
        const copy = getCopy();
        if (!isAdmin) {
          logTable.innerHTML = "";
          logTable.classList.remove("focus-mode");
          syncLogResetButtons();
          return;
        }
        const groupIds = Object.keys(GROUPS);
        if (!groupIds.length) {
          logTable.innerHTML = `<p class="muted">${copy.admin.noGroups}</p>`;
          logTable.classList.remove("focus-mode");
          syncLogResetButtons();
          return;
        }
        [...collapsedLogGroups].forEach((groupId) => {
          if (!isValidGroupId(groupId)) {
            collapsedLogGroups.delete(groupId);
          }
        });
        if (collapsedLogGroups.size >= groupIds.length) {
          collapsedLogGroups.delete(groupIds[0]);
        }
        saveLogLayout();
        const expandedGroupIds = groupIds.filter((id) => !collapsedLogGroups.has(id));
        const minimizedGroupIds = groupIds.filter((id) => collapsedLogGroups.has(id));
        const focusMode = expandedGroupIds.length === 1 && groupIds.length > 1;
        logTable.classList.toggle("focus-mode", focusMode);
        const fragment = document.createDocumentFragment();
        const selectedGroupId = focusMode ? expandedGroupIds[0] : null;
        const row = document.createElement("div");
        row.className = "group-chip-row";

        const showAllButton = document.createElement("button");
        showAllButton.type = "button";
        showAllButton.className = `ghost group-chip${collapsedLogGroups.size === 0 ? " active" : ""}`;
        showAllButton.textContent = copy.admin.showAll || copy.admin.exportScopeAll;
        showAllButton.setAttribute("aria-pressed", String(collapsedLogGroups.size === 0));
        showAllButton.addEventListener("click", () => {
          if (collapsedLogGroups.size === 0) return;
          collapsedLogGroups.clear();
          renderStaffLogs();
        });
        row.appendChild(showAllButton);

        groupIds.forEach((groupId) => {
          const chip = document.createElement("button");
          chip.type = "button";
          chip.className = `ghost group-chip${groupId === selectedGroupId ? " active" : ""}`;
          chip.textContent = t("admin.groupLabel", { group: groupLabel(groupId) });
          chip.setAttribute("aria-pressed", String(groupId === selectedGroupId));
          chip.addEventListener("click", () => {
            if (focusMode && groupId === selectedGroupId) return;
            collapsedLogGroups.clear();
            groupIds.forEach((id) => {
              if (id !== groupId) collapsedLogGroups.add(id);
            });
            renderStaffLogs();
          });
          row.appendChild(chip);
        });

        fragment.appendChild(row);

        let orderedGroupIds = [...expandedGroupIds, ...minimizedGroupIds];
        if (focusMode) {
          orderedGroupIds = [selectedGroupId];
        }
        orderedGroupIds.forEach((groupId) => {
          const roster = adminRosterData.get(groupId) ?? [];
          const isCollapsed = collapsedLogGroups.has(groupId);
          const card = document.createElement("div");
          card.className = `log-card${isCollapsed ? " minimized" : ""}`;

          const header = document.createElement("div");
          header.className = "log-card-header";

          const title = document.createElement("h3");
          title.textContent = t("admin.groupLabel", { group: groupLabel(groupId) });
          header.appendChild(title);

          const toggle = document.createElement("button");
          toggle.type = "button";
          toggle.className = "ghost admin-toggle";
          toggle.textContent = isCollapsed ? copy.admin.expand : copy.admin.collapse;
          const expandedCount = groupIds.length - collapsedLogGroups.size;
          toggle.disabled = !isCollapsed && expandedCount <= 1;
          toggle.setAttribute("aria-pressed", String(isCollapsed));
          toggle.setAttribute("aria-expanded", String(!isCollapsed));
          toggle.addEventListener("click", () => {
            const currentlyCollapsed = collapsedLogGroups.has(groupId);
            const expandedNow = groupIds.length - collapsedLogGroups.size;
            if (!currentlyCollapsed && expandedNow <= 1) {
              return;
            }
            setLogGroupCollapsed(groupId, !currentlyCollapsed);
          });
          header.appendChild(toggle);
          card.appendChild(header);

          const body = document.createElement("div");
          body.className = "log-card-body";

          if (!roster.length) {
            const empty = document.createElement("p");
            empty.className = "log-empty";
            empty.textContent = copy.admin.noUsers;
            body.appendChild(empty);
            card.appendChild(body);
            fragment.appendChild(card);
            return;
          }

          const table = document.createElement("table");
          const thead = document.createElement("thead");
          thead.innerHTML = `<tr>
            <th>${copy.logTable.worker}</th>
            <th>${copy.logTable.role}</th>
            <th>${copy.logTable.breaks}</th>
            <th>${copy.logTable.timeOnBreak}</th>
            <th>${copy.logTable.timeOnMeal}</th>
            <th>${copy.logTable.lastBreak}</th>
          </tr>`;
          table.appendChild(thead);

          const tbody = document.createElement("tbody");
          const sortedRoster = [...roster].sort((a, b) => {
            const statsA = getBreakStatsForToday(a);
            const statsB = getBreakStatsForToday(b);
            const totalA = statsA.breakDurationMs + currentBreakElapsed(a);
            const totalB = statsB.breakDurationMs + currentBreakElapsed(b);
            if (totalA !== totalB) return totalB - totalA;
            return (a.fullName ?? a.email ?? "").localeCompare(
              b.fullName ?? b.email ?? "",
              undefined,
              { sensitivity: "base" }
            );
          });
          sortedRoster.forEach((entry) => {
            const stats = getBreakStatsForToday(entry);
            const totalMs = stats.breakDurationMs + currentBreakElapsed(entry);
            const mealTotalMs = stats.mealBreakDurationMs + currentMealBreakElapsed(entry);
            const lastBreak = entry.lastBreakAt ?? null;
            const row = document.createElement("tr");
            const workerCell = document.createElement("td");
            workerCell.textContent = entry.fullName ?? entry.email ?? t("persons.unknown");
            workerCell.dataset.label = copy.logTable.worker;
            row.appendChild(workerCell);

            const roleCell = document.createElement("td");
            roleCell.textContent = roleLabel(entry.role) || t("persons.roleNotSet");
            roleCell.dataset.label = copy.logTable.role;
            row.appendChild(roleCell);

            const countCell = document.createElement("td");
            countCell.textContent = String(stats.breakCount ?? 0);
            countCell.dataset.label = copy.logTable.breaks;
            row.appendChild(countCell);

            const timeCell = document.createElement("td");
            timeCell.textContent = formatDuration(totalMs);
            timeCell.dataset.label = copy.logTable.timeOnBreak;
            row.appendChild(timeCell);

            const mealTimeCell = document.createElement("td");
            mealTimeCell.textContent = formatDuration(mealTotalMs);
            mealTimeCell.dataset.label = copy.logTable.timeOnMeal;
            row.appendChild(mealTimeCell);

            const lastBreakCell = document.createElement("td");
            lastBreakCell.textContent = formatRelativeTime(lastBreak);
            lastBreakCell.dataset.label = copy.logTable.lastBreak;
            row.appendChild(lastBreakCell);

            tbody.appendChild(row);
          });
          table.appendChild(tbody);
          body.appendChild(table);
          card.appendChild(body);
          fragment.appendChild(card);
        });

        logTable.replaceChildren(fragment);
        logTable.classList.toggle("hidden", logsCollapsed);
        syncLogCollapseButtons();
        syncLogResetButtons();
      }

      function startLogTicker() {
        stopLogTicker();
        if (!isAdmin) return;
        logRefreshTimer = setInterval(() => {
          renderStaffLogs();
        }, LOG_REFRESH_INTERVAL_MS);
      }

      function stopLogTicker() {
        if (logRefreshTimer) {
          clearInterval(logRefreshTimer);
          logRefreshTimer = null;
        }
      }

      async function resetLogsForGroups(groupIds) {
        if (!groupIds.length || !isAdmin) return;
        const copy = getCopy();
        isResettingLogs = true;
        syncLogResetButtons();
        const label =
          groupIds.length === Object.keys(GROUPS).length
            ? copy.admin.allGroups
            : groupIds.map((groupId) => t("admin.groupLabel", { group: groupLabel(groupId) })).join(", ");
        setLogMessage(t("messages.resettingLogs", { label }));
        try {
          for (const groupId of groupIds) {
            const rosterRef = collection(db, "groups", groupId, "busRoster");
            const snapshot = await getDocs(rosterRef);
            if (snapshot.empty) continue;
            const docs = snapshot.docs;
            for (let i = 0; i < docs.length; i += 400) {
              const batch = writeBatch(db);
              docs.slice(i, i + 400).forEach((docSnap) => {
                batch.set(
                  docSnap.ref,
                  {
                    isOnBreak: false,
                    joinedAt: null,
                    isOnMealBreak: false,
                    mealJoinedAt: null,
                    breakCount: 0,
                    breakDurationMs: 0,
                    mealBreakDurationMs: 0,
                    lastBreakAt: null,
                    logDateKey: currentResetDateKey(),
                    updatedAt: serverTimestamp(),
                  },
                  { merge: true }
                );
              });
              await batch.commit();
            }
          }
          setLogMessage(t("messages.logsReset", { label }));
        } catch (error) {
          console.error("Log reset failed", error);
          setLogMessage(t("messages.resetLogsFailed"), true);
        } finally {
          isResettingLogs = false;
          clearResetConfirmation(resetAllLogsButton);
          clearResetConfirmation(resetSelectedLogsButton);
          syncLogResetButtons();
        }
      }

      function startAdminRosterWatchers() {
        if (!isAdmin) return;
        stopAdminRosterWatchers();
        Object.keys(GROUPS).forEach((groupId) => {
          const rosterRef = collection(db, "groups", groupId, "busRoster");
          const unsubscribe = onSnapshot(
            rosterRef,
            (snapshot) => {
              const roster = snapshot.docs.map((docSnap) => normalizeRosterDocument(docSnap));
              adminRosterData.set(groupId, roster);
              renderAdminPanel();
            },
            (error) => {
              console.error(`Admin roster listener failed for group ${groupId}`, error);
            }
          );
          adminRosterUnsubscribes.set(groupId, unsubscribe);
        });
        renderAdminPanel();
      }

      function stopAdminRosterWatchers() {
        adminRosterUnsubscribes.forEach((unsubscribe) => {
          try {
            unsubscribe();
          } catch {
            /* ignore */
          }
        });
        adminRosterUnsubscribes.clear();
        adminRosterData.clear();
        renderAdminPanel();
      }

      async function ensureRosterEntry(user, groupId) {
        if (!user || !groupId) return;
        const ref = doc(db, "groups", groupId, "busRoster", user.uid);
        const fullName = getCurrentFullName() || user.email;
        try {
          const snapshot = await getDoc(ref);
          if (!snapshot.exists()) {
            const seed = {
              email: user.email,
              fullName,
              role: null,
              isOnBreak: false,
              isOnMealBreak: false,
              joinedAt: null,
              mealJoinedAt: null,
              lastBreakAt: null,
              breakCount: 0,
              breakDurationMs: 0,
              mealBreakDurationMs: 0,
              logDateKey: currentResetDateKey(),
              updatedAt: serverTimestamp(),
            };
            await setDoc(ref, seed);
            selfEntry = { id: user.uid, ...seed };
          } else {
            const data = snapshot.data();
            const roleId = sanitizeRoleId(data.role);
            const stats = getBreakStatsForToday(data);
            selfEntry = {
              id: user.uid,
              ...data,
              role: roleId,
              breakCount: stats.breakCount,
              breakDurationMs: stats.breakDurationMs,
              mealBreakDurationMs: stats.mealBreakDurationMs,
              lastBreakAt: data.lastBreakAt ?? null,
              logDateKey: stats.logDateKey,
            };
            if (stats.reset) {
              await setDoc(
                ref,
                {
                  breakCount: 0,
                  breakDurationMs: 0,
                  mealBreakDurationMs: 0,
                  lastBreakAt: data.lastBreakAt ?? null,
                  logDateKey: stats.logDateKey,
                  updatedAt: serverTimestamp(),
                },
                { merge: true }
              );
            }
            if (fullName && data.fullName !== fullName) {
              await setDoc(
                ref,
                {
                  fullName,
                  email: user.email,
                  updatedAt: serverTimestamp(),
                },
                { merge: true }
              );
              selfEntry.fullName = fullName;
            }
            if (data.role !== roleId) {
              await setDoc(
                ref,
                {
                  role: roleId || null,
                  updatedAt: serverTimestamp(),
                },
                { merge: true }
              );
            }
          }
          updateActionButtons();
          syncRoleUI(selfEntry);
        } catch (error) {
          console.error("Unable to prepare roster entry", error);
          setRosterMessage(t("messages.rosterSlotIssue"), true);
        }
      }

      function startRosterSubscription(groupId) {
        if (!groupId) return;
        stopRosterSubscription();
        const rosterRef = collection(db, "groups", groupId, "busRoster");
        rosterUnsubscribe = onSnapshot(
          rosterRef,
          (snapshot) => {
            rosterEntries = snapshot.docs.map((docSnap) => normalizeRosterDocument(docSnap));
            if (currentUser) {
              const latestSelf = rosterEntries.find((entry) => entry.id === currentUser.uid);
              if (latestSelf) {
                selfEntry = latestSelf;
              }
            }
            syncRoleUI(selfEntry);
            renderLists();
          },
          (error) => {
            console.error("Roster listener error", error);
            setRosterMessage(t("messages.rosterPaused"), true);
          }
        );
      }

      function stopRosterSubscription() {
        if (rosterUnsubscribe) {
          rosterUnsubscribe();
          rosterUnsubscribe = null;
        }
        rosterEntries = [];
        selfEntry = null;
        renderLists();
      }

      function startGroupWatcher(user) {
        stopGroupWatcher();
        if (!user) return;
        const groupRef = doc(db, "userGroups", user.uid);
        groupUnsubscribe = onSnapshot(
          groupRef,
          (snapshot) => {
            handleGroupSnapshot(snapshot).catch((error) => {
              console.error("Group handling failed", error);
              setGroupMessage(t("messages.loadGroupError"), true);
            });
          },
          (error) => {
            console.error("Group listener error", error);
            currentGroupId = null;
            setGroupMessage(t("messages.loadGroupError"), true);
            stopRosterSubscription();
            updateActionButtons();
            syncInfoCardVisibility();
          }
        );
      }

      function stopGroupWatcher() {
        if (groupUnsubscribe) {
          groupUnsubscribe();
          groupUnsubscribe = null;
        }
      }

      async function handleGroupSnapshot(snapshot) {
        if (!currentUser) return;
        if (!snapshot.exists()) {
          currentGroupId = null;
          setGroupMessage(t("messages.noGroupAssigned"), true);
          stopRosterSubscription();
          updateActionButtons();
          setRoleControlsDisabled(true);
          setRoleMessage(t("messages.roleAfterGroup"), true);
          syncRoleUI();
          syncInfoCardVisibility();
          return;
        }
        const data = snapshot.data();
        const groupId = data.groupId;
        if (!isValidGroupId(groupId)) {
          currentGroupId = null;
          setGroupMessage(t("messages.invalidGroup"), true);
          stopRosterSubscription();
          updateActionButtons();
          setRoleControlsDisabled(true);
          setRoleMessage(t("messages.roleAfterValidGroup"), true);
          syncRoleUI();
          syncInfoCardVisibility();
          return;
        }
        if (groupId === currentGroupId) {
          setGroupMessage(t("dashboard.groupLabel", { group: groupLabel(groupId) }));
          syncInfoCardVisibility();
          return;
        }
        currentGroupId = groupId;
        setGroupMessage(t("dashboard.groupLabel", { group: groupLabel(groupId) }));
        setRosterMessage("");
        setRoleMessage("");
        setRoleControlsDisabled(false);
        stopRosterSubscription();
        await ensureRosterEntry(currentUser, groupId);
        startRosterSubscription(groupId);
        syncInfoCardVisibility();
      }

      async function updateBreakStatus(targetState) {
        if (!currentUser || !currentGroupId || isRosterMutating) {
          if (!currentGroupId) {
            setRosterMessage(t("messages.needGroupBreak"), true);
          }
          return;
        }
        const currentEntry =
          rosterEntries.find((entry) => entry.id === currentUser.uid) ?? selfEntry ?? {};
        if (!sanitizeRoleId(currentEntry.role)) {
          setRoleMessage(t("messages.selectRoleFirst"), true);
          return;
        }
        if (targetState && isOnMealBreakToday(currentEntry)) {
          setRosterMessage(t("messages.endMealFirst"), true);
          return;
        }
        const stats = getBreakStatsForToday(currentEntry);
        let breakCount = stats.breakCount;
        let breakDurationMs = stats.breakDurationMs;
        const mealBreakDurationMs = stats.mealBreakDurationMs;
        const startingBreak = Boolean(targetState);
        const currentlyOnBreak = isOnBreakToday(currentEntry);
        const lastBreakAt = !startingBreak && currentlyOnBreak ? new Date() : currentEntry.lastBreakAt ?? null;
        isRosterMutating = true;
        updateActionButtons();
        setRosterMessage(startingBreak ? t("messages.startingBreak") : t("messages.endingBreak"));

        const fullName = getCurrentFullName() || currentUser.email;
        if (startingBreak) {
          if (!currentlyOnBreak) {
            breakCount += 1;
          }
        } else if (currentlyOnBreak) {
          const joinedAtDate = toDate(currentEntry.joinedAt);
          const elapsed = joinedAtDate ? Math.max(0, Date.now() - joinedAtDate.getTime()) : 0;
          breakDurationMs += elapsed;
        }
        const optimisticEntry = {
          id: currentUser.uid,
          email: currentUser.email,
          fullName,
          role: sanitizeRoleId(currentEntry.role) || null,
          isOnBreak: startingBreak,
          joinedAt: startingBreak ? new Date() : null,
          isOnMealBreak: currentEntry.isOnMealBreak ?? false,
          mealJoinedAt: currentEntry.mealJoinedAt ?? null,
          breakCount,
          breakDurationMs,
          lastBreakAt,
          mealBreakDurationMs,
          logDateKey: stats.logDateKey,
        };
        const index = rosterEntries.findIndex((entry) => entry.id === currentUser.uid);
        if (index >= 0) {
          rosterEntries[index] = { ...rosterEntries[index], ...optimisticEntry };
        } else {
          rosterEntries = [...rosterEntries, optimisticEntry];
        }
        selfEntry = optimisticEntry;
        renderLists();

        try {
          await setDoc(
            doc(db, "groups", currentGroupId, "busRoster", currentUser.uid),
            {
              email: currentUser.email,
              fullName,
              role: sanitizeRoleId(optimisticEntry.role) || null,
              isOnBreak: targetState,
              joinedAt: targetState ? serverTimestamp() : null,
              isOnMealBreak: optimisticEntry.isOnMealBreak ?? false,
              mealJoinedAt: optimisticEntry.mealJoinedAt ?? null,
              breakCount,
              breakDurationMs,
              lastBreakAt,
              mealBreakDurationMs,
              logDateKey: stats.logDateKey,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          setRosterMessage(targetState ? t("messages.onBreak") : t("messages.backFromBreak"));
        } catch (error) {
          console.error("Roster update failed", error);
          setRosterMessage(t("messages.breakUpdateFailed"), true);
        } finally {
          isRosterMutating = false;
          updateActionButtons();
        }
      }

      async function updateMealBreakStatus(targetState) {
        if (!currentUser || !currentGroupId || isRosterMutating) {
          if (!currentGroupId) {
            setRosterMessage(t("messages.needGroupMeal"), true);
          }
          return;
        }
        const currentEntry =
          rosterEntries.find((entry) => entry.id === currentUser.uid) ?? selfEntry ?? {};
        if (!sanitizeRoleId(currentEntry.role)) {
          setRoleMessage(t("messages.selectRoleFirst"), true);
          return;
        }
        if (targetState && isOnBreakToday(currentEntry)) {
          setRosterMessage(t("messages.endBreakFirst"), true);
          return;
        }
        const stats = getBreakStatsForToday(currentEntry);
        let breakCount = stats.breakCount;
        let breakDurationMs = stats.breakDurationMs;
        let mealBreakDurationMs = stats.mealBreakDurationMs;
        const currentlyOnMealBreak = isOnMealBreakToday(currentEntry);
        const startingMealBreak = Boolean(targetState);
        const lastBreakAt =
          !startingMealBreak && currentlyOnMealBreak
            ? new Date()
            : currentEntry.lastBreakAt ?? null;
        isRosterMutating = true;
        updateActionButtons();
        setRosterMessage(targetState ? t("messages.startingMeal") : t("messages.endingMeal"));

        if (startingMealBreak) {
          if (!currentlyOnMealBreak) {
            breakCount += 1;
          }
        } else if (currentlyOnMealBreak) {
          const elapsed = elapsedSince(currentEntry.mealJoinedAt);
          mealBreakDurationMs += elapsed;
        }

        const fullName = getCurrentFullName() || currentUser.email;
        const optimisticEntry = {
          id: currentUser.uid,
          email: currentUser.email,
          fullName,
          role: sanitizeRoleId(currentEntry.role) || null,
          isOnBreak: currentEntry.isOnBreak ?? false,
          joinedAt: currentEntry.joinedAt ?? null,
          isOnMealBreak: targetState,
          mealJoinedAt: startingMealBreak ? new Date() : null,
          breakCount,
          breakDurationMs,
          mealBreakDurationMs,
          lastBreakAt,
          logDateKey: stats.logDateKey,
        };
        const index = rosterEntries.findIndex((entry) => entry.id === currentUser.uid);
        if (index >= 0) {
          rosterEntries[index] = { ...rosterEntries[index], ...optimisticEntry };
        } else {
          rosterEntries = [...rosterEntries, optimisticEntry];
        }
        selfEntry = optimisticEntry;
        renderLists();

        try {
          await setDoc(
            doc(db, "groups", currentGroupId, "busRoster", currentUser.uid),
            {
              email: currentUser.email,
              fullName,
              role: sanitizeRoleId(optimisticEntry.role) || null,
              isOnBreak: optimisticEntry.isOnBreak ?? false,
              joinedAt: optimisticEntry.joinedAt ?? null,
              isOnMealBreak: targetState,
              mealJoinedAt: targetState ? serverTimestamp() : null,
              breakCount,
              breakDurationMs,
              mealBreakDurationMs,
              lastBreakAt,
              logDateKey: stats.logDateKey,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          setRosterMessage(targetState ? t("messages.onMeal") : t("messages.backFromMeal"));
        } catch (error) {
          console.error("Meal break update failed", error);
          setRosterMessage(t("messages.mealUpdateFailed"), true);
        } finally {
          isRosterMutating = false;
          updateActionButtons();
        }
      }

      async function updateRoleSelection() {
        if (!roleSelect) return;
        if (!currentUser) {
          setRoleMessage(t("messages.signInSetRole"), true);
          return;
        }
        if (!currentGroupId) {
          setRoleMessage(t("messages.waitForGroup"), true);
          return;
        }
        if (isRoleUpdating) return;
        const selectedRole = sanitizeRoleId(roleSelect?.value);
        isRoleUpdating = true;
        setRoleControlsDisabled(true);
        setRoleMessage(selectedRole ? t("messages.updatingRole") : t("messages.clearingRole"));

        const currentEntry =
          rosterEntries.find((entry) => entry.id === currentUser.uid) ?? selfEntry ?? {};
        const fullName = getCurrentFullName() || currentUser.email;
        const stats = getBreakStatsForToday(currentEntry);
        const optimisticEntry = {
          id: currentUser.uid,
          email: currentUser.email,
          fullName,
          role: selectedRole || null,
          isOnBreak: currentEntry.isOnBreak ?? false,
          joinedAt: currentEntry.joinedAt ?? null,
          isOnMealBreak: currentEntry.isOnMealBreak ?? false,
          mealJoinedAt: currentEntry.mealJoinedAt ?? null,
          breakCount: stats.breakCount,
          breakDurationMs: stats.breakDurationMs,
          mealBreakDurationMs: stats.mealBreakDurationMs,
          lastBreakAt: currentEntry.lastBreakAt ?? null,
          logDateKey: stats.logDateKey,
        };
        const index = rosterEntries.findIndex((entry) => entry.id === currentUser.uid);
        if (index >= 0) {
          rosterEntries[index] = { ...rosterEntries[index], ...optimisticEntry };
        } else {
          rosterEntries = [...rosterEntries, optimisticEntry];
        }
        selfEntry = optimisticEntry;
        syncRoleUI(optimisticEntry);
        renderLists();

        try {
          await setDoc(
            doc(db, "groups", currentGroupId, "busRoster", currentUser.uid),
            {
              email: currentUser.email,
              fullName,
              role: selectedRole || null,
              isOnBreak: optimisticEntry.isOnBreak ?? false,
              joinedAt: optimisticEntry.joinedAt ?? null,
              isOnMealBreak: optimisticEntry.isOnMealBreak ?? false,
              mealJoinedAt: optimisticEntry.mealJoinedAt ?? null,
              breakCount: stats.breakCount,
              breakDurationMs: stats.breakDurationMs,
              mealBreakDurationMs: stats.mealBreakDurationMs,
              lastBreakAt: optimisticEntry.lastBreakAt ?? null,
              logDateKey: stats.logDateKey,
              updatedAt: serverTimestamp(),
            },
            { merge: true }
          );
          setRoleMessage(selectedRole ? t("messages.roleUpdated") : t("messages.roleCleared"));
        } catch (error) {
          console.error("Role update failed", error);
          setRoleMessage(t("messages.roleUpdateFailed"), true);
        } finally {
          isRoleUpdating = false;
          setRoleControlsDisabled(!currentUser || !currentGroupId);
          syncRoleUI(selfEntry);
        }
      }

      function attemptFullNamePrefill() {
        if (authMode !== "register") return;
        const suggestion = recallFullName(emailInput.value.trim());
        if (suggestion && !fullNameInput.value.trim()) {
          fullNameInput.value = suggestion;
        }
      }

      modeButtons.forEach((button) => {
        button.addEventListener("click", () => setAuthMode(button.dataset.authMode));
      });

      languageSelects.forEach((select) => {
        select.addEventListener("change", (event) =>
          setLanguage(event.target.value, { persist: true })
        );
      });

      setFaqsCollapsed(faqsCollapsed, { persist: false });
      applyLanguage();

      emailInput.addEventListener("blur", attemptFullNamePrefill);
      emailInput.addEventListener("change", attemptFullNamePrefill);

      if (passwordToggleButton) {
        passwordToggleButton.addEventListener("click", () => {
          setPasswordVisibility(!isPasswordVisible);
          passwordInput?.focus();
        });
      }

      authForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const email = emailInput.value.trim();
        const isRegister = authMode === "register";
        const fullName = isRegister ? sanitizeFullName(fullNameInput.value) : "";
        if (isRegister) {
          fullNameInput.value = fullName;
        }
        const password = passwordInput.value.trim();

        if (!email) {
          setAuthMessage(t("messages.emailRequired"), true);
          return;
        }

        if (!password) {
          setAuthMessage(t("messages.passwordRequired"), true);
          return;
        }

        if (isRegister && !fullName) {
          setAuthMessage(t("messages.fullNameRequired"), true);
          return;
        }

        if (isRegister) {
          pendingIdentity = { email, fullName };
          rememberFullName(email, fullName);
        } else {
          pendingIdentity = null;
        }

        try {
          if (isRegister) {
            setAuthMessage(t("messages.creatingAccount"));
            await createUserWithEmailAndPassword(auth, email, password);
            setAuthMessage(t("messages.accountCreated"));
          } else {
            setAuthMessage(t("messages.signingIn"));
            await signInWithEmailAndPassword(auth, email, password);
            setAuthMessage(t("messages.signedIn"));
          }
        } catch (error) {
          const friendly =
            typeof error?.code === "string"
              ? error.code.replace("auth/", "").replace(/-/g, " ")
              : t("messages.authErrorFallback");
          setAuthMessage(friendly, true);
          pendingIdentity = null;
        }
      });

      joinButton.addEventListener("click", () => updateBreakStatus(true));
      leaveButton.addEventListener("click", () => updateBreakStatus(false));
      mealJoinButton.addEventListener("click", () => updateMealBreakStatus(true));
      mealLeaveButton.addEventListener("click", () => updateMealBreakStatus(false));
      if (roleSaveButton) {
        roleSaveButton.addEventListener("click", updateRoleSelection);
      }
      if (roleSelect) {
        roleSelect.addEventListener("change", () => setRoleMessage(""));
      }

      signOutButton.addEventListener("click", async () => {
        try {
          await signOut(auth);
          setAuthMessage(t("messages.signedOut"));
        } catch {
          setAuthMessage(t("messages.signOutError"), true);
        }
      });
      if (adminSignOutButton) {
        adminSignOutButton.addEventListener("click", () => signOutButton.click());
      }
      if (exportLogsButton) {
        exportLogsButton.addEventListener("click", () => exportLogsToCsv());
      }
      if (resetAllLogsButton) {
        resetAllLogsButton.addEventListener("click", () => {
          if (!isAdmin || isResettingLogs) return;
          const confirmed = requestResetConfirmation(
            resetAllLogsButton,
            t("admin.resetAllConfirm")
          );
          if (confirmed) {
            resetLogsForGroups(Object.keys(GROUPS));
          }
        });
      }
      if (resetSelectedLogsButton) {
        resetSelectedLogsButton.addEventListener("click", () => {
          if (!isAdmin || isResettingLogs || selectedLogGroups.size === 0) return;
          const confirmed = requestResetConfirmation(
            resetSelectedLogsButton,
            t("admin.resetSelectedConfirm")
          );
          if (confirmed) {
            resetLogsForGroups([...selectedLogGroups]);
          }
        });
      }

      if (infoFaqToggleButton) {
        infoFaqToggleButton.addEventListener("click", () => {
          setFaqsCollapsed(!faqsCollapsed);
        });
      }

      onAuthStateChanged(auth, async (user) => {
        currentUser = user;
        const adminStatus = user ? isAdminAccount(user) : false;
        setAdminMode(adminStatus);

        if (user) {
          userEmailEl.textContent = user.email;
          setRosterMessage("");
          setGroupMessage(adminStatus ? t("messages.breakOverview") : t("dashboard.lookingUpGroup"));
          setRoleMessage(adminStatus ? "" : t("dashboard.chooseRolePrompt"));
          setRoleControlsDisabled(true);
          try {
            if (pendingIdentity && pendingIdentity.email === user.email) {
              await saveProfileFullName(user, pendingIdentity.fullName);
              rememberFullName(user.email, pendingIdentity.fullName);
            }

            const profile = await fetchProfile(user);
            const profileFullName = profile?.fullName ? sanitizeFullName(profile.fullName) : "";
            const profileLanguage = isValidLanguage(profile?.language) ? profile.language : null;
            currentProfile = { fullName: profileFullName, language: profileLanguage };

            if (!currentProfile.fullName) {
              const suggestion = recallFullName(user.email);
              if (suggestion) {
                currentProfile.fullName = suggestion;
                rememberFullName(user.email, suggestion);
              } else if (!pendingIdentity) {
                setAuthMessage(t("messages.addFullNameLater"), true);
              }
            } else {
              rememberFullName(user.email, currentProfile.fullName);
            }

            if (profileLanguage) {
              setLanguage(profileLanguage, { persist: false });
            } else {
              currentProfile.language = currentLanguage;
              persistLanguagePreference(user, currentLanguage);
            }
          } catch (error) {
            console.error("Profile sync failed", error);
            setAuthMessage(t("messages.syncFullNameFailed"), true);
          } finally {
            pendingIdentity = null;
          }

          if (adminStatus) {
            startAdminRosterWatchers();
            stopGroupWatcher();
            stopRosterSubscription();
            currentGroupId = null;
          } else {
            stopAdminRosterWatchers();
            startGroupWatcher(user);
          }
        } else {
          userEmailEl.textContent = "—";
          setRosterMessage("");
          setGroupMessage("");
          setRoleMessage("");
          currentGroupId = null;
          currentProfile = { fullName: "", language: null };
          pendingIdentity = null;
          stopGroupWatcher();
          stopRosterSubscription();
          stopAdminRosterWatchers();
          setAdminMode(false);
          setRoleControlsDisabled(true);
          syncRoleUI(null);
        }

        toggleViews(Boolean(user));
        renderLists();
        renderAdminPanel();
        document.body.classList.remove("app-loading");
      });

      renderWorkInfo();
      renderLists();
      setupExportScopeControls();
    </script>
  </body>
</html>
